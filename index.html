<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=0.65">
    <title>Shift Scheduler Pro - Full Firebase</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; background-color: #f4f4f4; color: #333; }
        .app-shell { display: flex; flex-direction: column; min-height: 100vh; }
        .main-content-area { padding: 20px; display: flex; justify-content: center; align-items: flex-start; flex-grow: 1; }
        .app-container { width: 90%; max-width: 900px; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); margin-bottom: 20px; }
        .manager-dashboard { display: flex; flex-direction: column; width: 100%; min-height: 100vh; }
        .manager-top-bar { background-color: #333; color: white; padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; }
        .manager-top-bar h1 { color: white; margin:0; font-size: 1.5em; }
        .manager-body { display: flex; flex-grow: 1; }
        .manager-sidebar { width: 280px; background-color: #e9ecef; padding: 15px; border-right: 1px solid #ddd; overflow-y: auto; }
        .manager-main-content { flex-grow: 1; padding: 20px; overflow-y: auto; }
        .manager-main-flex-row { display: flex; gap: 20px; margin-bottom: 20px; }
        .manager-applications-column { flex: 3; min-width: 0; }
        .manager-hours-column { flex: 1; background-color: #f9f9f9; padding: 15px; border-radius: 5px; border: 1px solid #eee; min-width: 0; }
        .manager-hours-column h3 { margin-top: 0; } .manager-hours-column .input-group select { width: 100%; }
        .manager-schedule-preview { background-color: #fdfdfd; padding:15px; border-radius: 5px; margin-bottom: 20px; border: 1px solid #eee;}
        .add-shift-section { background-color: #f0f8ff; padding: 15px; border-radius: 5px; margin-bottom: 20px; border: 1px solid #cce5ff;}
        .add-shift-section .input-group { display: flex; flex-wrap: wrap; align-items: center; gap: 10px;}
        .add-shift-section .input-group label { margin-right: 5px; }
        .add-shift-section .input-group select, .add-shift-section .input-group input[type="text"], .add-shift-section .input-group input[type="time"] {
             padding: 8px; width: auto; min-width: 120px; margin-bottom: 0;
        }
        .add-shift-section .input-group input[type="text"]#addShiftDescriptionInput { flex-grow: 1; min-width: 200px; }
        .coworker-checkbox-group { margin-top: 10px; padding-top:10px; border-top: 1px dashed #ccc; width:100%;}
        .coworker-checkbox-group label { margin-right: 15px; font-weight: normal;}


        h1, h2, h3, h4 { color: #333; text-align: center; }
        h3 { margin-top: 25px; margin-bottom: 10px;} h4 { margin-top: 15px; margin-bottom: 5px; text-align: left;}
        table { width: 100%; border-collapse: collapse; margin-top: 10px; margin-bottom: 15px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; vertical-align: top; }
        th { background-color: #f0f0f0; }
        td.action-cell { min-width: 230px; text-align: center;}
        td.action-cell select { margin-bottom: 5px; width: 100%; padding: 5px; font-size: 0.9em;}
        td.action-cell select[multiple] { height: 70px; }
        .input-group { margin-bottom: 15px; }
        .input-group:not(.add-shift-section .input-group):not(.coworker-checkbox-group) label { display: block; margin-bottom: 5px; }
        .input-group:not(.add-shift-section .input-group) input[type="text"],
        .input-group:not(.add-shift-section .input-group) input[type="password"],
        .input-group:not(.add-shift-section .input-group) select {
            width: calc(100% - 22px); padding: 10px; border: 1px solid #ccc; border-radius: 4px;
        }
        button { padding: 10px 15px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.95em; margin-right: 5px; margin-top: 5px; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        button.approve, button.assign { background-color: #28a745; }
        button.approve:hover, button.assign:hover { background-color: #1e7e34; }
        button.deny, button.delete { background-color: #dc3545; } button.deny:hover, button.delete:hover { background-color: #c82333; }
        button.edit { background-color: #ffc107; color: #212529;} button.edit:hover { background-color: #e0a800;}
        button.apply { background-color: #ffc107; color: #333; } button.apply:hover { background-color: #e0a800; }
        button.secondary { background-color: #6c757d; } button.secondary:hover { background-color: #5a6268; }
        button.small-action { padding: 5px 10px; font-size: 0.8em; }
        button.publish { background-color: #17a2b8; } button.publish:hover { background-color: #117a8b; }
        .status-available { color: green; font-weight: bold; }
        .status-pending { color: orange; font-weight: bold; }
        .status-approved { color: blue; font-weight: bold; }
        .status-assigned { color: red; font-weight: bold; }
        .hidden { display: none !important; }
        #scheduleOverviewTable td, .manager-schedule-preview-table td, #latestPublishedScheduleTable td {text-align: center;}
        #totalHoursSummaryTable td, #totalHoursSummaryTable th { text-align: left; font-size: 0.9em; }
        #myPastShiftsTable td, #myPastShiftsTable th { text-align: left; font-size: 0.9em; }
        .coworker-management-item { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #eee; }
        .coworker-management-item:last-child { border-bottom: none; } .coworker-management-item span { flex-grow: 1; }
        .error-message { color: red; text-align: center; margin-top: 10px; }
        .success-message { color: green; text-align: center; margin-top: 10px; }
        .top-bar { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .week-navigation { text-align: center; margin-bottom: 10px; }
        .hours-overview-item { font-size: 0.9em; padding: 3px 0; }
        .published-status-indicator { font-size: 0.8em; font-style: italic; margin-top: 3px; text-align: center; }
        #totalHoursSummarySection { margin-top: 30px; padding-top: 20px; border-top: 2px solid #007bff;}
        #totalHoursSummarySection .input-group select {width: 250px; display: inline-block;}
        #myPastShiftsSection { margin-top: 20px; }
        .shift-description-display { font-size: 0.8em; color: #555; display: block; margin-top: 2px; font-style: italic;}
        .applicant-checkbox-item { display: block; margin-bottom: 3px; text-align: left; }
        .modal-checkbox-list { max-height: 150px; overflow-y: auto; margin-bottom: 15px; border: 1px solid #eee; padding: 10px; text-align: left;}
        .modal-checkbox-list label { display: block; margin-bottom: 5px; }


        /* --- START OF MOBILE RESPONSIVE STYLES --- */
        @media (max-width: 768px) { /* Styles for screens 768px wide or less */

            .main-content-area { padding: 10px; }
            .app-container { width: 95%; }
            .container { padding: 15px; }
            h1 { font-size: 1.6em; }
            h2 { font-size: 1.4em; }
            h3 { font-size: 1.15em; }
            button { padding: 12px 15px; }
            button.small-action { padding: 8px 10px; }
            .table-responsive-wrapper { overflow-x: auto; width: 100%; margin-bottom: 15px; -webkit-overflow-scrolling: touch; }
            td.action-cell { min-width: 150px; }
            td.action-cell select, td.action-cell button { width: 100% !important; margin-bottom: 8px; box-sizing: border-box; }
            td.action-cell button:last-child { margin-bottom: 0; }
            td.action-cell hr { display: none; }
            .table-responsive-wrapper table th, .table-responsive-wrapper table td { padding: 4px 3px; font-size: 0.8em; line-height: 1.2; white-space: nowrap; }
            .table-responsive-wrapper table td.action-cell { white-space: normal; min-width: 90px; }
            .table-responsive-wrapper table td.action-cell button.small-action, .table-responsive-wrapper table td.action-cell select { font-size: 0.7em; padding: 4px 5px; margin-bottom: 4px; }
            .table-responsive-wrapper table td.action-cell select { max-width: 100%; box-sizing: border-box; }
            .table-responsive-wrapper table td.action-cell button:last-child { margin-bottom: 0; }
            .table-responsive-wrapper table .shift-description-display { font-size: 0.7em; margin-top: 1px; line-height: 1.1; white-space: normal; }
            #userShiftViewWrapper .top-bar { flex-direction: column; align-items: flex-start; gap: 10px; }
            #userShiftViewWrapper .top-bar h2 { text-align: left; margin-bottom: 0; }
            #userShiftViewWrapper .top-bar div { display: flex; flex-direction: row; flex-wrap: wrap; gap: 10px; width: 100%; }
            #userShiftViewWrapper .top-bar div button { flex-grow: 1; min-width: 120px; }
            .week-navigation#userApplicationWeekNav { display: flex; flex-direction: column; align-items: center; gap: 8px; }
            .week-navigation#userApplicationWeekNav button { width: 80%; max-width: 280px; }
            #myPastShiftsSection .week-navigation { display: flex; flex-direction: column; align-items: center; gap: 10px; }
            #myPastShiftsSection .week-navigation select { width: 80%; max-width: 280px; }
            .manager-top-bar { flex-direction: column; align-items: flex-start; gap: 10px; padding: 10px 15px; }
            .manager-top-bar h1 { font-size: 1.3em; margin-bottom: 5px; }
            .manager-top-bar div { width: 100%; display: flex; flex-direction: column; align-items: flex-start; gap: 8px; }
            .manager-top-bar div span#managerLoggedInAs { margin-right: 0; margin-bottom: 5px; }
            .manager-top-bar div button.small-action { width: auto; padding: 8px 12px; }
            .manager-body { flex-direction: column; }
            .manager-sidebar { width: 100%; border-right: none; border-bottom: 1px solid #ddd; margin-bottom: 15px; max-height: none; overflow-y: visible; }
            .manager-sidebar .week-navigation { display: flex; flex-wrap: wrap; justify-content: space-around; gap: 5px; }
            .manager-sidebar .week-navigation button.small-action { flex-grow: 1; min-width: 100px; }
            .manager-sidebar h4 { margin-top: 15px; }
            .manager-main-content { padding: 10px; }
            .manager-main-flex-row { flex-direction: column; gap: 15px; }
            .manager-applications-column, .manager-hours-column { min-width: 100%; flex-basis: auto; }
            .add-shift-section .input-group { flex-direction: column; align-items: stretch; gap: 0; }
            .add-shift-section .input-group label { margin-bottom: 5px; margin-right: 0; width: 100%; }
            .add-shift-section .input-group select, .add-shift-section .input-group input[type="text"], .add-shift-section .input-group input[type="time"] { width: 100%; min-width: 0; margin-bottom: 10px; box-sizing: border-box; }
            .add-shift-section .input-group input[type="text"]#addShiftDescriptionInput { min-width: auto; }
            .coworker-checkbox-group { width: 100%; }
            .coworker-checkbox-group label { display: block; margin-bottom: 8px; margin-right: 0; }
            .add-shift-section button { width: 100%; margin-bottom: 5px; }
            .add-shift-section button:last-of-type { margin-bottom: 0; }
            .manager-main-content > h3 + .input-group { display: flex; flex-direction: column; }
            .manager-main-content > h3 + .input-group label, .manager-main-content > h3 + .input-group input[type="text"], .manager-main-content > h3 + .input-group input[type="password"], .manager-main-content > h3 + .input-group button { width: 100% !important; margin-top: 5px; margin-bottom: 5px; box-sizing: border-box; }
            .manager-main-content > h3 + .input-group label input[type="checkbox"] { width: auto !important; margin-right: 5px; }
            .coworker-management-item { flex-direction: column; align-items: flex-start; gap: 8px; }
            .coworker-management-item span { margin-bottom: 5px; }
            .coworker-management-item div { display: flex; flex-wrap: wrap; gap: 5px; }
            .input-group:not(.add-shift-section .input-group):not(.coworker-checkbox-group) input[type="text"], .input-group:not(.add-shift-section .input-group):not(.coworker-checkbox-group) input[type="password"], .input-group:not(.add-shift-section .input-group):not(.coworker-checkbox-group) select { width: 100%; box-sizing: border-box; }
            #changeMasterPasswordSection button { width: 100%; margin-bottom: 10px; }
            #changeMasterPasswordSection button.secondary { margin-top: 0; }
            #managerUnlockModal > div { width: 90%; max-width: 350px; padding: 20px; }
            #managerUnlockModal input[type="password"] { width: calc(100% - 22px); }
            #managerUnlockModal button { width: calc(50% - 5px); margin-right: 5px; }
            #managerUnlockModal button:last-of-type { margin-right: 0; }
            #assignEditModal > div { width: 90%; max-width: 400px; padding: 20px; } /* Style for new modal on mobile */
        }
        /* --- END OF MOBILE RESPONSIVE STYLES --- */
    </style>
</head>
<body>
    <div class="app-shell">
        <div id="initialLoginViewWrapper" class="main-content-area"><div class="app-container"><div id="initialLoginView" class="container view-section"><h1>Shift Scheduler Login</h1><div class="input-group"><label for="loginUserSelect">Select Your Name:</label><select id="loginUserSelect"><option value="">-- Select Name --</option></select></div><div class="input-group"><label for="loginPassword">Password:</label><input type="password" id="loginPassword"></div><button id="coworkerLoginBtn">Login</button><p id="initialLoginError" class="error-message"></p></div></div></div>

        <div id="userShiftViewWrapper" class="main-content-area hidden">
            <div class="app-container">
                <div id="latestPublishedScheduleSection" class="container hidden">
                    <h2 id="latestPublishedScheduleTitle">Latest Published Schedule</h2>
                    <div class="table-responsive-wrapper">
                        <table id="latestPublishedScheduleTable"><thead><tr><th>Day</th><th>9:30 - 13:00</th><th>13:00 - 16:30</th></tr></thead><tbody></tbody></table>
                    </div>
                </div>
                <div id="userShiftView" class="container view-section">
                    <div class="top-bar"><h2 id="welcomeUserName">Welcome, [User]!</h2><div><button id="accessManagerPanelBtn" class="secondary hidden">Manager Panel</button><button id="userLogoutBtn" class="secondary">Logout</button></div></div>
                    <div class="week-navigation" id="userApplicationWeekNav" style="margin-bottom: 15px; border-bottom: 1px solid #eee; padding-bottom: 10px;">
                        <button id="prevUserAppWeekBtn" class="small-action">« Prev App Week</button>
                        <strong id="currentUserAppWeekDisplay" style="margin: 0 10px; font-size: 1.1em;"></strong>
                        <button id="nextUserAppWeekBtn" class="small-action">Next App Week »</button>
                    </div>
                    <h3>Available Shifts & Your Applications</h3>
                    <div class="table-responsive-wrapper">
                        <table id="userShiftsTable"><thead><tr><th>Day</th><th>Date</th><th>Time & Description</th><th>Status</th><th>Action</th></tr></thead><tbody></tbody></table>
                    </div>
                </div>
                <div id="myPastShiftsSection" class="container view-section hidden">
                    <h3>My Past Shifts History</h3>
                    <div class="week-navigation">
                        <button id="prevPastPeriodBtn" class="small-action">« Previous</button>
                        <select id="pastShiftsViewTypeSelect" style="padding:5px; font-size:0.9em; margin: 0 10px;">
                            <option value="weekly">View by Week</option>
                            <option value="monthly">View by Month</option>
                        </select>
                        <button id="nextPastPeriodBtn" class="small-action">Next »</button>
                    </div>
                    <p style="text-align:center; font-size:0.9em;" id="myPastShiftsPeriodDisplay"></p>
                    <div class="table-responsive-wrapper">
                        <table id="myPastShiftsTable">
                            <thead><tr><th>Date</th><th>Day</th><th>Time & Description</th></tr></thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <div id="managerDashboardView" class="manager-dashboard hidden">
            <div class="manager-top-bar"><h1>Manager Dashboard</h1><div><span id="managerLoggedInAs" style="margin-right:20px;"></span><button id="switchToUserViewBtn" class="secondary small-action">My Shifts View</button><button id="managerDashboardLogoutBtn" class="secondary small-action">Logout</button></div></div>
            <div class="manager-body">
                <div class="manager-sidebar"><h4>Week Navigation</h4><div class="week-navigation"><button id="prevWeekBtnMgr" class="small-action">« Prev Wk</button><button id="jumpToTargetWeekBtnMgr" class="small-action">Next Wk</button><button id="nextWeekBtnMgr" class="small-action">Further Wk »</button></div><p style="text-align:center; font-size:0.9em; margin-bottom:5px;" id="managerSidebarWeekDisplay"></p><hr><h4>Week Actions</h4><button id="publishWeekBtn" class="publish small-action" style="width:100%; margin-bottom:5px;">Publish Week</button><div id="publishStatusIndicator" class="published-status-indicator">Status: Not Published</div><hr><h4>Admin Settings</h4><button id="showChangeMasterPassBtn" class="secondary small-action" style="width:100%; margin-bottom:10px;">Change Master Password</button><button id="resetAllDataBtn" class="delete small-action" style="width:100%;">Reset All Data</button></div>
                <div class="manager-main-content">
                    <div id="changeMasterPasswordSection" class="container hidden" style="border: 1px solid #ffc107; background: #fff9e6;"><h3>Change Master Admin Password</h3><div class="input-group"><label for="currentMasterPassword">Current Master Password:</label><input type="password" id="currentMasterPassword"></div><div class="input-group"><label for="newMasterPassword">New Master Password:</label><input type="password" id="newMasterPassword"></div><div class="input-group"><label for="confirmNewMasterPassword">Confirm New Password:</label><input type="password" id="confirmNewMasterPassword"></div><button id="submitChangeMasterPassBtn">Change Password</button><button id="cancelChangeMasterPassBtn" class="secondary">Cancel</button><p id="changeMasterPassError" class="error-message"></p><p id="changeMasterPassSuccess" class="success-message"></p></div>

                    <div class="add-shift-section container">
                        <h3 id="addUpdateShiftTitle">Add New Shift to Current Week</h3>
                        <div class="input-group">
                            <label for="addShiftDaySelect">Day:</label>
                            <select id="addShiftDaySelect">
                                <option value="Monday">Monday</option><option value="Tuesday">Tuesday</option><option value="Wednesday">Wednesday</option><option value="Thursday">Thursday</option><option value="Friday">Friday</option>
                            </select>
                            <label for="addShiftTimeTypeSelect">Time Slot Type:</label>
                            <select id="addShiftTimeTypeSelect">
                                <option value="9:30 - 13:00">Standard 9:30 - 13:00</option>
                                <option value="13:00 - 16:30">Standard 13:00 - 16:30</option>
                                <option value="custom">Custom Time</option>
                            </select>
                        </div>
                        <div class="input-group hidden" id="customTimeInputs">
                            <label for="addShiftCustomStartTime">Start (HH:MM):</label>
                            <input type="time" id="addShiftCustomStartTime">
                            <label for="addShiftCustomEndTime">End (HH:MM):</label>
                            <input type="time" id="addShiftCustomEndTime">
                        </div>
                        <div class="input-group hidden" id="descriptionInputGroup">
                            <label for="addShiftDescriptionInput">Description (Optional):</label>
                            <input type="text" id="addShiftDescriptionInput" placeholder="e.g., Special Event, Meeting">
                        </div>
                        <div class="coworker-checkbox-group hidden" id="assignCoworkersForCustomShift">
                            <h4>Assign Coworkers:</h4>
                        </div>
                        <button id="managerAddShiftBtn">Add Shift</button>
                        <button id="cancelEditShiftBtn" class="secondary hidden">Cancel Edit</button>
                    </div>

                    <div class="manager-schedule-preview"><h3 id="managerSchedulePreviewTitle">Shift Schedule Preview: Week of [Date]</h3>
                        <div class="table-responsive-wrapper">
                            <table id="managerSchedulePreviewTable" class="manager-schedule-preview-table"><thead><tr><th>Day</th><th>9:30 - 13:00</th><th>13:00 - 16:30</th></tr></thead><tbody></tbody></table>
                        </div>
                    </div>
                    <div class="manager-main-flex-row">
                        <div class="manager-applications-column"><h3>Shift Applications Management</h3><p style="text-align:center; font-size:0.9em;" id="managerApplicationWeekDisplay"></p>
                            <div class="table-responsive-wrapper">
                                <table id="managerShiftsTable"><thead><tr><th>Day</th><th>Date</th><th>Time & Description</th><th>Status</th><th>Applicants / Assigned</th><th>Actions</th></tr></thead><tbody></tbody></table>
                            </div>
                        </div>
                        <div class="manager-hours-column"><h3>Hours Overview</h3><div class="input-group" style="margin-bottom:5px;"><select id="hoursViewTypeSelect"><option value="weekly">Weekly Hours</option><option value="monthly">Monthly Hours</option></select></div><div id="hoursOverviewList"></div></div>
                    </div>
                    <h3>Manage Coworkers</h3><div class="input-group"><label for="newCoworkerName">Add Name:</label><input type="text" id="newCoworkerName" placeholder="Coworker's name"><label for="newCoworkerPassword" style="margin-top:5px;">Set Password:</label><input type="password" id="newCoworkerPassword" placeholder="Initial password"><label style="margin-top:5px;"><input type="checkbox" id="newCoworkerIsManager"> Is Manager?</label><button id="addCoworkerBtn" style="margin-top:10px;">Add Coworker</button></div><div id="coworkerList"></div>
                    <div id="totalHoursSummarySection" class="container"><h3>Total Hours Summary per Coworker</h3><div class="input-group"><label for="totalHoursPeriodSelect" style="display:inline-block; margin-right:10px;">Select Period:</label><select id="totalHoursPeriodSelect"><option value="viewing_week">Currently Viewed Week</option><option value="viewing_month">Currently Viewed Month</option><option value="all_loaded">All Loaded Data</option></select></div>
                        <div class="table-responsive-wrapper">
                            <table id="totalHoursSummaryTable"><thead><tr><th>Coworker</th><th>Total Approved Hours</th></tr></thead><tbody></tbody></table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="managerUnlockModal" class="hidden" style="position:fixed; top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5); display:flex; justify-content:center; align-items:center;"><div style="background:white; padding:30px; border-radius:8px; box-shadow: 0 0 15px rgba(0,0,0,0.3); text-align:center;"><h3>Manager Panel Access</h3><p>Enter Master Admin Password:</p><input type="password" id="masterManagerPasswordInput" style="padding:10px; margin-bottom:15px; width:200px;"><br><button id="unlockManagerPanelBtn">Unlock</button><button id="cancelManagerUnlockBtn" class="secondary">Cancel</button><p id="managerUnlockError" class="error-message"></p></div></div>

        <!-- CUSTOM MODALS HTML START -->
        <div id="customAlertModal" class="hidden" style="position:fixed; top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6); display:flex; justify-content:center; align-items:center; z-index: 1000;">
            <div style="background:white; padding:25px; border-radius:8px; box-shadow: 0 0 15px rgba(0,0,0,0.3); text-align:center; min-width: 280px; max-width: 90%;">
                <h3 id="customAlertTitle" style="margin-top:0; margin-bottom:15px;">Alert</h3>
                <p id="customAlertMessage" style="margin-bottom:20px;">This is the alert message.</p>
                <button id="customAlertOkBtn" class="approve">OK</button>
            </div>
        </div>

        <div id="customConfirmModal" class="hidden" style="position:fixed; top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6); display:flex; justify-content:center; align-items:center; z-index: 1000;">
            <div style="background:white; padding:25px; border-radius:8px; box-shadow: 0 0 15px rgba(0,0,0,0.3); text-align:center; min-width: 280px; max-width: 90%;">
                <h3 id="customConfirmTitle" style="margin-top:0; margin-bottom:15px;">Confirm</h3>
                <p id="customConfirmMessage" style="margin-bottom:20px;">Are you sure?</p>
                <button id="customConfirmYesBtn" class="approve" style="margin-right:10px;">Yes</button>
                <button id="customConfirmNoBtn" class="secondary">No</button>
            </div>
        </div>

        <div id="customPromptModal" class="hidden" style="position:fixed; top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6); display:flex; justify-content:center; align-items:center; z-index: 1000;">
            <div style="background:white; padding:25px; border-radius:8px; box-shadow: 0 0 15px rgba(0,0,0,0.3); text-align:center; min-width: 300px; max-width: 90%;">
                <h3 id="customPromptTitle" style="margin-top:0; margin-bottom:15px;">Prompt</h3>
                <p id="customPromptMessage" style="margin-bottom:10px;">Enter value:</p>
                <input type="text" id="customPromptInput" style="width: calc(100% - 22px); padding: 10px; margin-bottom: 20px; border: 1px solid #ccc; border-radius: 4px;">
                <button id="customPromptOkBtn" class="approve" style="margin-right:10px;">OK</button>
                <button id="customPromptCancelBtn" class="secondary">Cancel</button>
            </div>
        </div>

        <div id="assignEditModal" class="hidden" style="position:fixed; top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.6); display:flex; justify-content:center; align-items:center; z-index: 1001;">
            <div style="background:white; padding:25px; border-radius:8px; box-shadow: 0 0 15px rgba(0,0,0,0.3); text-align:center; min-width: 320px; max-width: 90%;">
                <h3 id="assignEditModalTitle" style="margin-top:0; margin-bottom:15px;">Assign/Edit Coworkers</h3>
                <div id="assignEditCoworkerList" class="modal-checkbox-list">
                    <!-- Coworker checkboxes will be populated here by JavaScript -->
                </div>
                <button id="assignEditSaveBtn" class="approve" style="margin-right:10px;">Save Assignments</button>
                <button id="assignEditCancelBtn" class="secondary">Cancel</button>
            </div>
        </div>
        <!-- CUSTOM MODALS HTML END -->
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>


    <script>
        const firebaseConfig = { apiKey: "AIzaSyDkJwykLgHJknOjhsplI_BC77DZJ1wc3Sc", authDomain: "makersplayce-shift-planner.firebaseapp.com", databaseURL: "https://makersplayce-shift-planner-default-rtdb.europe-west1.firebasedatabase.app", projectId: "makersplayce-shift-planner", storageBucket: "makersplayce-shift-planner.firebasestorage.app", messagingSenderId: "484080846181", appId: "1:484080846181:web:3120dd6711d51a6e8f4d8c", measurementId: "G-171W3Y9YQB" };
        const app = firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        const auth = firebase.auth();

        const DEFAULT_MASTER_PASSWORD = "superadmin";
        const ACTIVE_SESSION_USER_KEY = "activeShiftUser_v7_firebase_cached";
        const dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
        const workDays = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"];
        const standardShiftTimes = ["9:30 - 13:00", "13:00 - 16:30"];
        const SHIFT_DURATION_HOURS = 3.5;
        const USER_APPLICATION_WEEKS_FORWARD = 4;

        let currentMasterPassword = DEFAULT_MASTER_PASSWORD;
        let coworkers = [];
        let loggedInCoworker = null;
        let isManagerModeActive = false;
        let currentViewingDateMgr;
        let allShiftsData = {};
        let currentPastShiftViewDate;
        let currentUserApplicationViewingDate;
        let editingShiftId = null; // Used by the top form "Add/Update Shift"
        let currentShiftForModal = null; // To store shift context for the new assign/edit modal

        const initialLoginViewWrapper = document.getElementById('initialLoginViewWrapper');
        const loginUserSelect = document.getElementById('loginUserSelect');
        const loginPasswordInput = document.getElementById('loginPassword');
        const coworkerLoginBtn = document.getElementById('coworkerLoginBtn');
        const initialLoginError = document.getElementById('initialLoginError');
        const userShiftViewWrapper = document.getElementById('userShiftViewWrapper');
        const latestPublishedScheduleSection = document.getElementById('latestPublishedScheduleSection');
        const latestPublishedScheduleTitle = document.getElementById('latestPublishedScheduleTitle');
        const latestPublishedScheduleTableBody = document.getElementById('latestPublishedScheduleTable').getElementsByTagName('tbody')[0];
        const welcomeUserName = document.getElementById('welcomeUserName');
        const accessManagerPanelBtn = document.getElementById('accessManagerPanelBtn');
        const userLogoutBtn = document.getElementById('userLogoutBtn');
        const userShiftsTableBody = document.getElementById('userShiftsTable').getElementsByTagName('tbody')[0];
        const prevUserAppWeekBtn = document.getElementById('prevUserAppWeekBtn');
        const currentUserAppWeekDisplay = document.getElementById('currentUserAppWeekDisplay');
        const nextUserAppWeekBtn = document.getElementById('nextUserAppWeekBtn');
        const myPastShiftsSection = document.getElementById('myPastShiftsSection');
        const prevPastPeriodBtn = document.getElementById('prevPastPeriodBtn');
        const pastShiftsViewTypeSelect = document.getElementById('pastShiftsViewTypeSelect');
        const nextPastPeriodBtn = document.getElementById('nextPastPeriodBtn');
        const myPastShiftsPeriodDisplay = document.getElementById('myPastShiftsPeriodDisplay');
        const myPastShiftsTableBody = document.getElementById('myPastShiftsTable').getElementsByTagName('tbody')[0];
        const managerUnlockModal = document.getElementById('managerUnlockModal');
        const masterManagerPasswordInput = document.getElementById('masterManagerPasswordInput');
        const unlockManagerPanelBtn = document.getElementById('unlockManagerPanelBtn');
        const cancelManagerUnlockBtn = document.getElementById('cancelManagerUnlockBtn');
        const managerUnlockError = document.getElementById('managerUnlockError');
        const managerDashboardView = document.getElementById('managerDashboardView');
        const managerLoggedInAs = document.getElementById('managerLoggedInAs');
        const switchToUserViewBtn = document.getElementById('switchToUserViewBtn');
        const managerDashboardLogoutBtn = document.getElementById('managerDashboardLogoutBtn');
        const prevWeekBtnMgr = document.getElementById('prevWeekBtnMgr');
        const jumpToTargetWeekBtnMgr = document.getElementById('jumpToTargetWeekBtnMgr');
        const nextWeekBtnMgr = document.getElementById('nextWeekBtnMgr');
        const publishWeekBtn = document.getElementById('publishWeekBtn');
        const publishStatusIndicator = document.getElementById('publishStatusIndicator');
        const showChangeMasterPassBtn = document.getElementById('showChangeMasterPassBtn');
        const changeMasterPasswordSection = document.getElementById('changeMasterPasswordSection');
        const currentMasterPasswordInput = document.getElementById('currentMasterPassword');
        const newMasterPasswordInput = document.getElementById('newMasterPassword');
        const confirmNewMasterPasswordInput = document.getElementById('confirmNewMasterPassword');
        const submitChangeMasterPassBtn = document.getElementById('submitChangeMasterPassBtn');
        const cancelChangeMasterPassBtn = document.getElementById('cancelChangeMasterPassBtn');
        const changeMasterPassError = document.getElementById('changeMasterPassError');
        const changeMasterPassSuccess = document.getElementById('changeMasterPassSuccess');
        const managerSidebarWeekDisplay = document.getElementById('managerSidebarWeekDisplay');
        const hoursViewTypeSelect = document.getElementById('hoursViewTypeSelect');
        const hoursOverviewList = document.getElementById('hoursOverviewList');
        const resetAllDataBtn = document.getElementById('resetAllDataBtn');
        const managerSchedulePreviewTitle = document.getElementById('managerSchedulePreviewTitle');
        const managerSchedulePreviewTableBody = document.getElementById('managerSchedulePreviewTable').getElementsByTagName('tbody')[0];
        const managerApplicationWeekDisplay = document.getElementById('managerApplicationWeekDisplay');
        const managerShiftsTableBody = document.getElementById('managerShiftsTable').getElementsByTagName('tbody')[0];
        const newCoworkerNameInput = document.getElementById('newCoworkerName');
        const newCoworkerPasswordInput = document.getElementById('newCoworkerPassword');
        const newCoworkerIsManagerCheckbox = document.getElementById('newCoworkerIsManager');
        const addCoworkerBtn = document.getElementById('addCoworkerBtn');
        const coworkerListDiv = document.getElementById('coworkerList');
        const totalHoursPeriodSelect = document.getElementById('totalHoursPeriodSelect');
        const totalHoursSummaryTableBody = document.getElementById('totalHoursSummaryTable').getElementsByTagName('tbody')[0];
        const addUpdateShiftTitle = document.getElementById('addUpdateShiftTitle');
        const addShiftDaySelect = document.getElementById('addShiftDaySelect');
        const addShiftTimeTypeSelect = document.getElementById('addShiftTimeTypeSelect');
        const customTimeInputsDiv = document.getElementById('customTimeInputs');
        const addShiftCustomStartTimeInput = document.getElementById('addShiftCustomStartTime');
        const addShiftCustomEndTimeInput = document.getElementById('addShiftCustomEndTime');
        const descriptionInputGroup = document.getElementById('descriptionInputGroup');
        const addShiftDescriptionInput = document.getElementById('addShiftDescriptionInput');
        const managerAddShiftBtn = document.getElementById('managerAddShiftBtn');
        const cancelEditShiftBtn = document.getElementById('cancelEditShiftBtn');
        const assignCoworkersForCustomShiftDiv = document.getElementById('assignCoworkersForCustomShift');

        const customAlertModal = document.getElementById('customAlertModal');
        const customAlertTitle = document.getElementById('customAlertTitle');
        const customAlertMessage = document.getElementById('customAlertMessage');
        const customAlertOkBtn = document.getElementById('customAlertOkBtn');
        const customConfirmModal = document.getElementById('customConfirmModal');
        const customConfirmTitle = document.getElementById('customConfirmTitle');
        const customConfirmMessage = document.getElementById('customConfirmMessage');
        const customConfirmYesBtn = document.getElementById('customConfirmYesBtn');
        const customConfirmNoBtn = document.getElementById('customConfirmNoBtn');
        const customPromptModal = document.getElementById('customPromptModal');
        const customPromptTitle = document.getElementById('customPromptTitle');
        const customPromptMessage = document.getElementById('customPromptMessage');
        const customPromptInput = document.getElementById('customPromptInput');
        const customPromptOkBtn = document.getElementById('customPromptOkBtn');
        const customPromptCancelBtn = document.getElementById('customPromptCancelBtn');
        
        const assignEditModal = document.getElementById('assignEditModal');
        const assignEditModalTitle = document.getElementById('assignEditModalTitle');
        const assignEditCoworkerListDiv = document.getElementById('assignEditCoworkerList');
        const assignEditSaveBtn = document.getElementById('assignEditSaveBtn');
        const assignEditCancelBtn = document.getElementById('assignEditCancelBtn');

        let currentConfirmResolve = null;
        let currentPromptResolve = null;

        function showAlert(message, title = "Alert") { customAlertTitle.textContent = title; customAlertMessage.textContent = message; customAlertModal.classList.remove('hidden'); customAlertModal.style.display = 'flex'; return new Promise((resolve) => { customAlertOkBtn.onclick = () => { customAlertModal.classList.add('hidden'); customAlertModal.style.display = 'none'; resolve(true); }; }); }
        function showConfirm(message, title = "Confirm") { customConfirmTitle.textContent = title; customConfirmMessage.textContent = message; customConfirmModal.classList.remove('hidden'); customConfirmModal.style.display = 'flex'; return new Promise((resolve) => { currentConfirmResolve = resolve; }); }
        function showPrompt(message, defaultValue = "", title = "Prompt") { customPromptTitle.textContent = title; customPromptMessage.textContent = message; customPromptInput.value = defaultValue; customPromptModal.classList.remove('hidden'); customPromptModal.style.display = 'flex'; customPromptInput.focus(); return new Promise((resolve) => { currentPromptResolve = resolve; }); }
        if (customAlertOkBtn) { customAlertOkBtn.addEventListener('click', () => { if (!customAlertModal.classList.contains('hidden')) { customAlertModal.classList.add('hidden'); customAlertModal.style.display = 'none'; } }); }
        if (customConfirmYesBtn) { customConfirmYesBtn.addEventListener('click', () => { customConfirmModal.classList.add('hidden'); customConfirmModal.style.display = 'none'; if (currentConfirmResolve) { currentConfirmResolve(true); currentConfirmResolve = null; } }); }
        if (customConfirmNoBtn) { customConfirmNoBtn.addEventListener('click', () => { customConfirmModal.classList.add('hidden'); customConfirmModal.style.display = 'none'; if (currentConfirmResolve) { currentConfirmResolve(false); currentConfirmResolve = null; } }); }
        if (customPromptOkBtn) { customPromptOkBtn.addEventListener('click', () => { customPromptModal.classList.add('hidden'); customPromptModal.style.display = 'none'; if (currentPromptResolve) { currentPromptResolve(customPromptInput.value); currentPromptResolve = null; } }); }
        if (customPromptCancelBtn) { customPromptCancelBtn.addEventListener('click', () => { customPromptModal.classList.add('hidden'); customPromptModal.style.display = 'none'; if (currentPromptResolve) { currentPromptResolve(null); currentPromptResolve = null; } }); }

        function getMondayOfDate(d) { d = new Date(d); const day = d.getDay(); const diff = d.getDate() - day + (day === 0 ? -6 : 1); const monday = new Date(d.setDate(diff)); monday.setHours(0,0,0,0); return monday; }
        function getNextWeekStartDate(fromDate) { const baseDate = fromDate ? new Date(fromDate) : new Date(); const monday = getMondayOfDate(baseDate); monday.setDate(monday.getDate() + 7); return monday; }
        function formatDate(dateObj, includeDayName = true) { if (!dateObj || !(dateObj instanceof Date) || isNaN(dateObj.getTime())) return 'Invalid Date'; const dayStr = includeDayName ? `${dayNames[dateObj.getDay()]}, ` : ''; return `${dayStr}${dateObj.toLocaleString('default', { month: 'short' })} ${dateObj.getDate()}, ${dateObj.getFullYear()}`; }
        function getWeekKey(dateObj) { return getMondayOfDate(dateObj).toISOString().split('T')[0]; }
        function getDateForDayInWeek(targetDayName, weekStartDate) { const monday = getMondayOfDate(new Date(weekStartDate)); const dayIndex = workDays.indexOf(targetDayName); if (dayIndex === -1) return null; const shiftSpecificDate = new Date(monday); shiftSpecificDate.setDate(monday.getDate() + dayIndex); return shiftSpecificDate.toISOString(); }
        function getStartTimeMinutes(timeStr) { if (!timeStr || typeof timeStr !== 'string') return Infinity; const parts = timeStr.split(' - ')[0].split(':'); if (parts.length === 2) { const hours = parseInt(parts[0], 10); const minutes = parseInt(parts[1], 10); if (!isNaN(hours) && !isNaN(minutes)) { return hours * 60 + minutes; } } return Infinity; }
        function sortShiftsArray(shifts) { if (!Array.isArray(shifts)) return; shifts.sort((a, b) => { const dateDiff = new Date(a.date).getTime() - new Date(b.date).getTime(); if (dateDiff !== 0) return dateDiff; return getStartTimeMinutes(a.time) - getStartTimeMinutes(b.time); }); }

        async function ensureFirebaseAnonymousAuth() { if (!auth.currentUser) { try { await auth.signInAnonymously(); } catch (error) { console.error("Critical Firebase Anonymous Auth Error on initial ensure:", error); if(initialLoginViewWrapper && !initialLoginViewWrapper.classList.contains('hidden')){ initialLoginError.textContent = "Critical error: Could not establish secure session.";} else { await showAlert("Critical error: Could not establish secure session.");} throw error;}}}
        async function initializeApp() { try { await ensureFirebaseAnonymousAuth(); await loadMasterPassword(); currentViewingDateMgr = getNextWeekStartDate(); currentPastShiftViewDate = getMondayOfDate(new Date()); currentUserApplicationViewingDate = getNextWeekStartDate(); await initializeCoworkers(); populateLoginUserDropdown(); populateCoworkerCheckboxesForCustomShift(); await checkActiveSession(); resetAddShiftForm(); } catch (error) { console.error("Error during app initialization:", error); if(initialLoginError && typeof initialLoginError.textContent !== 'undefined') { initialLoginError.textContent = "Failed to initialize. Check console, or refresh.";}}}
        async function loadMasterPassword() { try { const configRef = db.collection('config').doc('adminConfig'); let doc; try { doc = await configRef.get(); } catch (readError) { console.warn("Reading adminConfig failed (expected if rules are 'allow read: if false;'). Using default master password."); } if (doc && doc.exists && doc.data().masterAdminPassword) { currentMasterPassword = doc.data().masterAdminPassword; } else { console.warn("Admin config or master password not found or not readable. Using default and attempting to save (if rules permit)."); currentMasterPassword = DEFAULT_MASTER_PASSWORD; try { await configRef.set({ masterAdminPassword: DEFAULT_MASTER_PASSWORD }, { merge: true }); console.log("Default master password written/updated in Firestore config."); } catch (setConfigError) { console.error("Could not save default master password to Firestore (check rules for config/adminConfig create/update):", setConfigError); } } } catch (error) { console.error("Error in loadMasterPassword logic:", error); currentMasterPassword = DEFAULT_MASTER_PASSWORD; } }
        async function getWeekData(weekStartDate) { const weekKey = getWeekKey(weekStartDate); if (allShiftsData[weekKey]) { if (allShiftsData[weekKey] && Array.isArray(allShiftsData[weekKey].shifts) && typeof allShiftsData[weekKey].isPublished === 'boolean') { sortShiftsArray(allShiftsData[weekKey].shifts); return JSON.parse(JSON.stringify(allShiftsData[weekKey])); } else { delete allShiftsData[weekKey]; } } const weekDocRef = db.collection('shifts').doc(weekKey); try { const doc = await weekDocRef.get(); if (doc.exists) { let data = doc.data(); if (typeof data !== 'object' || data === null) data = {}; if (!Array.isArray(data.shifts)) { data.shifts = []; } if (typeof data.isPublished !== 'boolean') { data.isPublished = false; } data.shifts.forEach(s => { if (s && !Array.isArray(s.applicants)) s.applicants = []; if (s && !Array.isArray(s.assignedCoworkers)) s.assignedCoworkers = []; if (s && !s.description && standardShiftTimes.includes(s.time)) { s.description = "Normal Shift"; } }); sortShiftsArray(data.shifts); allShiftsData[weekKey] = JSON.parse(JSON.stringify(data)); return data; } else { const newWeekShifts = []; let idCounter = Date.now(); for (let i = 0; i < workDays.length; i++) { const dayName = workDays[i]; const currentShiftDate = new Date(weekStartDate); currentShiftDate.setDate(weekStartDate.getDate() + i); standardShiftTimes.forEach(time => { newWeekShifts.push({ id: `${weekKey}-${idCounter++}`, day: dayName, date: currentShiftDate.toISOString(), time: time, status: "available", applicants: [], applicantName: "", description: "Normal Shift", assignedCoworkers: [] }); }); } const newWeekData = { shifts: newWeekShifts, isPublished: false }; sortShiftsArray(newWeekData.shifts); await weekDocRef.set(newWeekData); allShiftsData[weekKey] = JSON.parse(JSON.stringify(newWeekData)); return newWeekData; } } catch (error) { console.error(`Error getting week data for ${weekKey}:`, error); const fallbackData = { shifts: [], isPublished: false, error: true, errorMessage: error.message }; allShiftsData[weekKey] = JSON.parse(JSON.stringify(fallbackData)); return fallbackData; } }
        async function getShiftsForWeek(weekStartDate) { const weekData = await getWeekData(weekStartDate); return weekData; }
        async function initializeCoworkers() { try { const snapshot = await db.collection('coworkers').get(); if (snapshot.empty) { coworkers = [ { name: "Ties", password: "1234", isManager: true }, { name: "Joep", password: "1234", isManager: false }, { name: "Jesper", password: "1234", isManager: false }, { name: "Inti", password: "1234", isManager: false }, { name: "Martijn", password: "1234", isManager: false }, { name: "Mathijs", password: "1234", isManager: false }, { name: "Dominik", password: "1234", isManager: false }, { name: "Jippe", password: "1234", isManager: false }, { name: "Zeynep", password: "1234", isManager: false } ]; const batch = db.batch(); coworkers.forEach(cw => { const docRef = db.collection('coworkers').doc(cw.name); batch.set(docRef, cw); }); await batch.commit(); } else { coworkers = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); } } catch (error) { console.error("Error initializing coworkers:", error); coworkers = []; throw error; } }
        function showCorrectView() { [initialLoginViewWrapper, userShiftViewWrapper, managerDashboardView, managerUnlockModal, changeMasterPasswordSection, myPastShiftsSection, customAlertModal, customConfirmModal, customPromptModal, assignEditModal].forEach(v => { if(v) v.classList.add('hidden'); }); if (isManagerModeActive && loggedInCoworker && loggedInCoworker.isManager) { managerDashboardView.classList.remove('hidden'); managerLoggedInAs.textContent = `Logged in as: ${loggedInCoworker.name}`; refreshManagerDashboard(); } else if (loggedInCoworker) { userShiftViewWrapper.classList.remove('hidden'); prepareUserView(); } else { initialLoginViewWrapper.classList.remove('hidden'); } }
        async function checkActiveSession() { const activeUserJSON = localStorage.getItem(ACTIVE_SESSION_USER_KEY); if (activeUserJSON) { const activeUser = JSON.parse(activeUserJSON); const foundCoworker = coworkers.find(c => c.name === activeUser.name); if (foundCoworker && activeUser.password === foundCoworker.password) { try { await ensureFirebaseAnonymousAuth(); loggedInCoworker = foundCoworker; } catch (error) { logout(); return; } } else { logout(); return; } } showCorrectView(); }
        function populateLoginUserDropdown() { loginUserSelect.innerHTML = '<option value="">-- Select Name --</option>'; coworkers.sort((a, b) => a.name.localeCompare(b.name)).forEach(coworker => { const option = document.createElement('option'); option.value = coworker.name; option.textContent = coworker.name; loginUserSelect.appendChild(option); }); }
        async function handleCoworkerLogin() { const selectedName = loginUserSelect.value; const password = loginPasswordInput.value; initialLoginError.textContent = ""; if (!selectedName || !password) { initialLoginError.textContent = "Name and password are required."; return; } const coworker = coworkers.find(c => c.name === selectedName); if (coworker && coworker.password === password) { try { await ensureFirebaseAnonymousAuth(); loggedInCoworker = coworker; localStorage.setItem(ACTIVE_SESSION_USER_KEY, JSON.stringify({name: coworker.name, password: coworker.password})); loginPasswordInput.value = ""; isManagerModeActive = false; currentUserApplicationViewingDate = getNextWeekStartDate(); showCorrectView(); } catch (error) { console.error("Firebase Anonymous Auth Error:", error); initialLoginError.textContent = "Login failed. Auth session error."; } } else { initialLoginError.textContent = "Invalid name or password."; loginPasswordInput.value = ""; } }
        function handleAccessManagerPanel() { if (loggedInCoworker && loggedInCoworker.isManager) { managerUnlockModal.classList.remove('hidden'); masterManagerPasswordInput.value = ""; managerUnlockError.textContent = ""; masterManagerPasswordInput.focus(); } }
        function handleUnlockManagerPanel() { if (masterManagerPasswordInput.value === currentMasterPassword) { isManagerModeActive = true; managerUnlockModal.classList.add('hidden'); showCorrectView(); } else { managerUnlockError.textContent = "Incorrect Master Password."; } }
        function logout() { if (auth.currentUser) { auth.signOut().catch((error) => { console.error("Error signing out from Firebase Auth:", error); });} loggedInCoworker = null; isManagerModeActive = false; localStorage.removeItem(ACTIVE_SESSION_USER_KEY); loginPasswordInput.value = ""; masterManagerPasswordInput.value = ""; initialLoginError.textContent = ""; managerUnlockError.textContent = ""; if (changeMasterPasswordSection) changeMasterPasswordSection.classList.add('hidden'); resetAddShiftForm(); showCorrectView(); }
        async function prepareUserView() { if (!loggedInCoworker) return; welcomeUserName.textContent = `Welcome, ${loggedInCoworker.name}!`; accessManagerPanelBtn.classList.toggle('hidden', !loggedInCoworker.isManager); if (myPastShiftsSection) { myPastShiftsSection.classList.remove('hidden'); await renderMyPastShifts(); } try { const querySnapshot = await db.collection('shifts').where('isPublished', '==', true).orderBy(firebase.firestore.FieldPath.documentId(), 'desc').limit(1).get(); if (!querySnapshot.empty) { const latestPublishedWeekKey = querySnapshot.docs[0].id; let latestPublishedWeekData; const weekDocRef = db.collection('shifts').doc(latestPublishedWeekKey); const doc = await weekDocRef.get(); if (doc.exists) { latestPublishedWeekData = doc.data(); if (typeof latestPublishedWeekData !== 'object' || latestPublishedWeekData === null) latestPublishedWeekData = {}; if (!Array.isArray(latestPublishedWeekData.shifts)) { latestPublishedWeekData.shifts = []; } if (typeof latestPublishedWeekData.isPublished !== 'boolean') { latestPublishedWeekData.isPublished = (doc.data() && typeof doc.data().isPublished === 'boolean') ? doc.data().isPublished : false; } latestPublishedWeekData.shifts.forEach(s => { if (s && !Array.isArray(s.applicants)) s.applicants = []; if (s && !Array.isArray(s.assignedCoworkers)) s.assignedCoworkers = []; if (s && !s.description && standardShiftTimes.includes(s.time)) { s.description = "Normal Shift"; } }); sortShiftsArray(latestPublishedWeekData.shifts); allShiftsData[latestPublishedWeekKey] = JSON.parse(JSON.stringify(latestPublishedWeekData)); if (latestPublishedWeekData.shifts) { latestPublishedScheduleTitle.textContent = `Latest Published Schedule: Week of ${formatDate(new Date(latestPublishedWeekKey), false)}`; renderScheduleOverview(latestPublishedWeekData.shifts, latestPublishedScheduleTableBody); latestPublishedScheduleSection.classList.remove('hidden'); } else { if (latestPublishedScheduleSection) latestPublishedScheduleSection.classList.add('hidden'); } } else { if (latestPublishedScheduleSection) latestPublishedScheduleSection.classList.add('hidden'); } } else { if (latestPublishedScheduleSection) latestPublishedScheduleSection.classList.add('hidden'); } if (!currentUserApplicationViewingDate) { currentUserApplicationViewingDate = getNextWeekStartDate(); } await renderCurrentUserApplicationWeek(); } catch (error) { console.error("Error preparing user view (outer try-catch):", error); if(currentUserAppWeekDisplay) currentUserAppWeekDisplay.textContent = "Error loading shifts."; if(latestPublishedScheduleSection) latestPublishedScheduleSection.classList.add('hidden'); } }
        async function renderCurrentUserApplicationWeek() { if (!loggedInCoworker || !currentUserApplicationViewingDate) return; const firstAllowedAppDate = getNextWeekStartDate(); const lastAllowedAppDate = new Date(firstAllowedAppDate); lastAllowedAppDate.setDate(firstAllowedAppDate.getDate() + (USER_APPLICATION_WEEKS_FORWARD * 7)); if (currentUserAppWeekDisplay) { currentUserAppWeekDisplay.textContent = `Application Week: ${formatDate(currentUserApplicationViewingDate, false)}`; } const weekData = await getShiftsForWeek(currentUserApplicationViewingDate); if (weekData.error) { if(userShiftsTableBody) userShiftsTableBody.innerHTML = '<tr><td colspan="5">Error loading shifts.</td></tr>'; } else if (weekData.shifts) { sortShiftsArray(weekData.shifts); renderUserShifts(weekData.shifts, currentUserApplicationViewingDate); } else { if(userShiftsTableBody) userShiftsTableBody.innerHTML = '<tr><td colspan="5">No shifts available for this week.</td></tr>'; } if (prevUserAppWeekBtn) { prevUserAppWeekBtn.disabled = currentUserApplicationViewingDate.getTime() <= firstAllowedAppDate.getTime(); } if (nextUserAppWeekBtn) { nextUserAppWeekBtn.disabled = getMondayOfDate(new Date(currentUserApplicationViewingDate)).getTime() >= getMondayOfDate(new Date(lastAllowedAppDate)).getTime(); } }

        function renderUserShifts(shiftsForWeek, forWeekDate) {
            userShiftsTableBody.innerHTML = "";
            if (!shiftsForWeek || !Array.isArray(shiftsForWeek) || !loggedInCoworker) {
                userShiftsTableBody.innerHTML = `<tr><td colspan="5">Error: Could not load shifts or user not logged in.</td></tr>`;
                return;
            }
            shiftsForWeek.forEach(shift => {
                const row = userShiftsTableBody.insertRow();
                row.insertCell().textContent = shift.day;
                row.insertCell().textContent = formatDate(new Date(shift.date), false);
                const timeCell = row.insertCell();
                timeCell.textContent = shift.time;

                const effectiveDescription = (!shift.description && standardShiftTimes.includes(shift.time)) ? "Normal Shift" : shift.description;
                if (effectiveDescription) {
                    const descSpan = document.createElement('span');
                    descSpan.classList.add('shift-description-display');
                    descSpan.textContent = effectiveDescription;
                    timeCell.appendChild(descSpan);
                }

                const statusCell = row.insertCell();
                const actionCell = row.insertCell();
                actionCell.classList.add("action-cell");

                const isMyAppPending = shift.status === 'pending' && Array.isArray(shift.applicants) && shift.applicants.includes(loggedInCoworker.name);
                const isApprovedForMe = shift.status === 'approved' && Array.isArray(shift.assignedCoworkers) && shift.assignedCoworkers.includes(loggedInCoworker.name);
                const isApprovedForSomeoneElse = shift.status === 'approved' && Array.isArray(shift.assignedCoworkers) && shift.assignedCoworkers.length > 0 && !shift.assignedCoworkers.includes(loggedInCoworker.name);

                let canIStillApply = false;
                if (shift.status === 'available') {
                    canIStillApply = true;
                } else if (shift.status === 'pending' && !isMyAppPending && !isApprovedForMe && !isApprovedForSomeoneElse) {
                    canIStillApply = true;
                }

                if (isApprovedForMe) {
                    statusCell.textContent = "Approved";
                    statusCell.className = 'status-approved';
                    actionCell.textContent = "---";
                } else if (isMyAppPending) {
                    statusCell.textContent = "Pending";
                    statusCell.className = 'status-pending';
                    const cancelBtn = document.createElement('button');
                    cancelBtn.textContent = "Cancel App";
                    cancelBtn.classList.add("deny", "small-action");
                    cancelBtn.onclick = () => cancelApplication(shift.id, getWeekKey(forWeekDate));
                    actionCell.appendChild(cancelBtn);
                } else if (isApprovedForSomeoneElse) {
                    statusCell.textContent = "Assigned";
                    statusCell.className = 'status-assigned';
                    actionCell.textContent = "---";
                } else if (canIStillApply) {
                    statusCell.textContent = "Available";
                    statusCell.className = 'status-available';
                    const applyButton = document.createElement('button');
                    applyButton.textContent = "Apply";
                    applyButton.classList.add("apply", "small-action");
                    applyButton.onclick = () => applyForShift(shift.id, getWeekKey(forWeekDate));
                    actionCell.appendChild(applyButton);
                } else {
                    if(shift.status === 'pending' && !isApprovedForSomeoneElse && !isApprovedForMe){
                         statusCell.textContent = "Available";
                         statusCell.className = 'status-available';
                         const applyButton = document.createElement('button');
                         applyButton.textContent = "Apply";
                         applyButton.classList.add("apply", "small-action");
                         applyButton.onclick = () => applyForShift(shift.id, getWeekKey(forWeekDate));
                         actionCell.appendChild(applyButton);
                    } else {
                        statusCell.textContent = shift.status.charAt(0).toUpperCase() + shift.status.slice(1);
                        if (shift.status === 'approved') statusCell.className = 'status-assigned';
                        else statusCell.className = `status-${shift.status}`;
                        actionCell.textContent = "---";
                    }
                }
            });
        }


        function renderScheduleOverview(shiftsForWeek, tableBodyElement) { tableBodyElement.innerHTML = ""; if (!shiftsForWeek || !Array.isArray(shiftsForWeek)) { tableBodyElement.innerHTML = '<tr><td colspan="3">Error: Could not load schedule.</td></tr>'; return; } sortShiftsArray(shiftsForWeek); const scheduleData = {}; workDays.forEach(day => { scheduleData[day] = {}; standardShiftTimes.forEach(time => scheduleData[day][time] = { names: [], description: "" }); }); shiftsForWeek.filter(s => s.status === "approved").forEach(shift => { const namesToDisplay = (Array.isArray(shift.assignedCoworkers) && shift.assignedCoworkers.length > 0) ? shift.assignedCoworkers : (shift.applicantName ? [shift.applicantName] : []); if (standardShiftTimes.includes(shift.time)) { if (scheduleData[shift.day] && scheduleData[shift.day][shift.time]) { scheduleData[shift.day][shift.time].names = namesToDisplay; scheduleData[shift.day][shift.time].description = (!shift.description && standardShiftTimes.includes(shift.time)) ? "Normal Shift" : (shift.description || ""); } } }); workDays.forEach(day => { const row = tableBodyElement.insertRow(); const dayCell = row.insertCell(); const shiftOnThisDay = shiftsForWeek.find(s => s.day === day); dayCell.innerHTML = `${day}<br><small>${shiftOnThisDay ? formatDate(new Date(shiftOnThisDay.date), false) : ''}</small>`; standardShiftTimes.forEach(time => { const cell = row.insertCell(); const assignedNames = scheduleData[day][time].names; cell.textContent = assignedNames.length > 0 ? assignedNames.join(', ') : "Unassigned"; if (scheduleData[day][time].description) { const descSpan = document.createElement('span'); descSpan.classList.add('shift-description-display'); descSpan.textContent = scheduleData[day][time].description; cell.appendChild(descSpan); } if (assignedNames.length > 0) { cell.style.fontWeight = "bold"; } }); }); const customApprovedShifts = shiftsForWeek.filter(s => s.status === "approved" && !standardShiftTimes.includes(s.time)); if (customApprovedShifts.length > 0) { const customHeaderRow = tableBodyElement.insertRow(); const customHeaderCell = customHeaderRow.insertCell(); customHeaderCell.colSpan = 3; customHeaderCell.innerHTML = "<b>Other Approved Shifts / Events</b>"; customHeaderCell.style.textAlign = "center"; customHeaderCell.style.backgroundColor = "#f9f9f9"; customApprovedShifts.forEach(shift => { const row = tableBodyElement.insertRow(); row.insertCell().innerHTML = `${shift.day}<br><small>${formatDate(new Date(shift.date), false)}</small>`; const timeDescCell = row.insertCell(); timeDescCell.textContent = shift.time; if (shift.description) { const descSpan = document.createElement('span'); descSpan.classList.add('shift-description-display'); descSpan.textContent = shift.description; timeDescCell.appendChild(descSpan); } row.insertCell().textContent = (Array.isArray(shift.assignedCoworkers) && shift.assignedCoworkers.length > 0) ? shift.assignedCoworkers.join(', ') : (shift.applicantName || "Error"); }); } }
        async function refreshManagerDashboard() { if (!isManagerModeActive) return; try { const weekData = await getWeekData(currentViewingDateMgr); if (weekData.error || !weekData.shifts) { managerSidebarWeekDisplay.textContent = "Error loading week."; managerApplicationWeekDisplay.textContent = "Error loading apps."; managerSchedulePreviewTitle.textContent = "Error loading schedule."; if(managerShiftsTableBody) managerShiftsTableBody.innerHTML = '<tr><td colspan="6">Error loading shifts.</td></tr>'; if(managerSchedulePreviewTableBody) managerSchedulePreviewTableBody.innerHTML = '<tr><td colspan="3">Error loading preview.</td></tr>'; if(hoursOverviewList) hoursOverviewList.innerHTML = "<p>Error loading hours.</p>"; return; } const shiftsForViewingWeek = weekData.shifts; sortShiftsArray(shiftsForViewingWeek); managerSidebarWeekDisplay.textContent = `Week: ${formatDate(currentViewingDateMgr, false)}`; managerApplicationWeekDisplay.textContent = `Apps for week: ${formatDate(currentViewingDateMgr, false)}`; managerSchedulePreviewTitle.textContent = `Schedule: Week of ${formatDate(currentViewingDateMgr, false)}`; renderManagerApplications(shiftsForViewingWeek); renderScheduleOverview(shiftsForViewingWeek, managerSchedulePreviewTableBody); renderCoworkerListForManager(); renderHoursOverview(shiftsForViewingWeek); await renderTotalHoursSummary(); if (weekData.isPublished) { publishWeekBtn.textContent = "Unpublish Week"; publishWeekBtn.classList.remove("publish"); publishWeekBtn.classList.add("deny"); publishStatusIndicator.textContent = "Status: Published"; publishStatusIndicator.style.color = "green"; } else { publishWeekBtn.textContent = "Publish Week"; publishWeekBtn.classList.add("publish"); publishWeekBtn.classList.remove("deny"); publishStatusIndicator.textContent = "Status: Not Published"; publishStatusIndicator.style.color = "orange"; } } catch (error) { console.error("Error refreshing manager dashboard:", error); } }

        // MODIFIED renderManagerApplications
        function renderManagerApplications(shiftsForWeek) {
            managerShiftsTableBody.innerHTML = ""; if (!shiftsForWeek || !Array.isArray(shiftsForWeek)) { managerShiftsTableBody.innerHTML = '<tr><td colspan="6">Error: Could not load applications.</td></tr>'; return; }
            sortShiftsArray(shiftsForWeek);
            shiftsForWeek.forEach(shift => {
                const row = managerShiftsTableBody.insertRow();
                row.insertCell().textContent = shift.day;
                row.insertCell().textContent = formatDate(new Date(shift.date), false);
                const timeCell = row.insertCell(); timeCell.textContent = shift.time;
                const effectiveDescription = (!shift.description && standardShiftTimes.includes(shift.time)) ? "Normal Shift" : shift.description;
                if (effectiveDescription) {
                    const descSpan = document.createElement('span');
                    descSpan.classList.add('shift-description-display');
                    descSpan.textContent = effectiveDescription;
                    timeCell.appendChild(descSpan);
                }
                const statusCell = row.insertCell(); statusCell.textContent = shift.status.charAt(0).toUpperCase() + shift.status.slice(1); statusCell.className = `status-${shift.status}`;
                let applicantDisplay = "---";
                if (shift.status === "approved") { if (Array.isArray(shift.assignedCoworkers) && shift.assignedCoworkers.length > 0) { applicantDisplay = shift.assignedCoworkers.join(', '); } else if (shift.applicantName) { applicantDisplay = shift.applicantName; }
                } else if (shift.status === "pending" && Array.isArray(shift.applicants) && shift.applicants.length > 0) { applicantDisplay = shift.applicants.join(', '); }
                row.insertCell().textContent = applicantDisplay;
                const actionCell = row.insertCell(); actionCell.classList.add("action-cell"); const weekKey = getWeekKey(new Date(shift.date));

                if (shift.status === "pending" && Array.isArray(shift.applicants) && shift.applicants.length > 0) {
                    const applicantCheckboxContainer = document.createElement('div');
                    applicantCheckboxContainer.id = `checkbox-container-pending-${shift.id}`;
                    applicantCheckboxContainer.style.textAlign = 'left';
                    applicantCheckboxContainer.style.maxHeight = '100px';
                    applicantCheckboxContainer.style.overflowY = 'auto';
                    applicantCheckboxContainer.style.marginBottom = '5px';

                    shift.applicants.forEach(appName => {
                        const checkboxLabel = document.createElement('label');
                        checkboxLabel.classList.add('applicant-checkbox-item');
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.value = appName;
                        checkbox.name = `pending-applicant-${shift.id}`;
                        checkbox.style.marginRight = '5px';
                        checkboxLabel.appendChild(checkbox);
                        checkboxLabel.appendChild(document.createTextNode(appName));
                        applicantCheckboxContainer.appendChild(checkboxLabel);
                    });
                    actionCell.appendChild(applicantCheckboxContainer);

                    const approveSelectedBtn = document.createElement('button');
                    approveSelectedBtn.textContent = "Approve Sel.";
                    approveSelectedBtn.classList.add("approve", "small-action");
                    approveSelectedBtn.onclick = async () => {
                        const selectedNames = [];
                        const checkboxes = document.querySelectorAll(`input[name="pending-applicant-${shift.id}"]:checked`);
                        checkboxes.forEach(cb => selectedNames.push(cb.value));
                        if (selectedNames.length > 0) {
                            await managerApproveMultipleApplicants(shift.id, weekKey, selectedNames);
                        } else {
                            await showAlert("Please select at least one applicant to approve.");
                        }
                    };
                    actionCell.appendChild(approveSelectedBtn);

                    const denyAllBtn = document.createElement('button');
                    denyAllBtn.textContent = "Deny All";
                    denyAllBtn.classList.add("deny", "small-action");
                    denyAllBtn.style.marginLeft = "5px";
                    denyAllBtn.onclick = async () => await managerDenyAllApplicants(shift.id, weekKey);
                    actionCell.appendChild(denyAllBtn);
                }
                else if (shift.status === "approved") {
                    const editBtn = document.createElement('button');
                    editBtn.textContent = "Edit Assignment(s)";
                    editBtn.classList.add("edit", "small-action");
                    editBtn.style.marginBottom = "5px";
                    editBtn.onclick = () => openAssignEditModal(shift, weekKey, true); // true for edit mode
                    actionCell.appendChild(editBtn);

                    const clearBtn = document.createElement('button');
                    clearBtn.textContent = "Clear Assignment(s)";
                    clearBtn.classList.add("deny", "small-action");
                    clearBtn.onclick = async () => {
                        const confirmClear = await showConfirm("Are you sure you want to clear all assignments for this shift?");
                        if (confirmClear) {
                            await managerClearApprovedShift(shift.id, weekKey);
                        }
                    };
                    actionCell.appendChild(clearBtn);
                }
                if (shift.status === "available") {
                    if (actionCell.childNodes.length > 0 && actionCell.lastChild.tagName !== 'HR' ) actionCell.appendChild(document.createElement('hr'));
                    
                    const assignBtn = document.createElement('button');
                    assignBtn.textContent = "Assign Coworker(s)";
                    assignBtn.classList.add("assign", "small-action");
                    assignBtn.onclick = () => openAssignEditModal(shift, weekKey, false); // false for new assignment
                    actionCell.appendChild(assignBtn);
                }
                if (actionCell.childNodes.length > 0 && actionCell.lastChild.tagName !== 'HR' && shift.status !== "pending") { // Avoid double HR after pending
                    actionCell.appendChild(document.createElement('hr'));
                }
                const deleteShiftBtn = document.createElement('button'); deleteShiftBtn.textContent = "Delete Shift"; deleteShiftBtn.classList.add("delete", "small-action"); deleteShiftBtn.style.marginTop = "5px"; deleteShiftBtn.onclick = () => managerDeleteShift(shift.id, weekKey); actionCell.appendChild(deleteShiftBtn);
            });
        }

        function renderHoursOverview(shiftsForViewingWeek) { hoursOverviewList.innerHTML = ""; if (!shiftsForViewingWeek || !Array.isArray(shiftsForViewingWeek)) { hoursOverviewList.innerHTML = "<p>Could not load hours.</p>"; return; } const type = hoursViewTypeSelect.value; const hoursData = {}; coworkers.forEach(c => hoursData[c.name] = 0); const processShiftHours = (shift) => { if (standardShiftTimes.includes(shift.time)) return SHIFT_DURATION_HOURS; if (shift.time && shift.time.includes(' - ')) { try { const [startStr, endStr] = shift.time.split(' - '); const [startH, startM] = startStr.split(':').map(Number); const [endH, endM] = endStr.split(':').map(Number); if (!isNaN(startH) && !isNaN(startM) && !isNaN(endH) && !isNaN(endM)) { const startDate = new Date(0,0,0,startH,startM); const endDate = new Date(0,0,0,endH,endM); let diffMillis = endDate - startDate; if (diffMillis < 0) diffMillis += 24 * 60 * 60 * 1000; return diffMillis / (1000 * 60 * 60); } } catch(e) { return 0; } } return 0; }; if (type === "weekly") { shiftsForViewingWeek.filter(s => s.status === "approved").forEach(s => { const duration = processShiftHours(s); if (s.applicantName && hoursData.hasOwnProperty(s.applicantName)) { hoursData[s.applicantName] += duration; } else if (Array.isArray(s.assignedCoworkers)) { s.assignedCoworkers.forEach(name => { if(hoursData.hasOwnProperty(name)) hoursData[name] += duration; }); } }); } else if (type === "monthly") { const targetMonth = currentViewingDateMgr.getMonth(); const targetYear = currentViewingDateMgr.getFullYear(); for (const weekKey in allShiftsData) { const weekStartDate = new Date(weekKey); if (weekStartDate.getMonth() === targetMonth && weekStartDate.getFullYear() === targetYear && allShiftsData[weekKey] && Array.isArray(allShiftsData[weekKey].shifts)) { allShiftsData[weekKey].shifts.filter(s => s.status === "approved").forEach(s => { const duration = processShiftHours(s); if (s.applicantName && hoursData.hasOwnProperty(s.applicantName)) { hoursData[s.applicantName] += duration; } else if (Array.isArray(s.assignedCoworkers)) { s.assignedCoworkers.forEach(name => { if(hoursData.hasOwnProperty(name)) hoursData[name] += duration; }); } }); } } } const sortedCoworkers = Object.keys(hoursData).sort(); sortedCoworkers.forEach(name => { const item = document.createElement('div'); item.classList.add('hours-overview-item'); item.textContent = `${name}: ${hoursData[name].toFixed(1)} hrs`; hoursOverviewList.appendChild(item); }); }
        async function renderMyPastShifts() { if (!loggedInCoworker) { if (myPastShiftsSection) myPastShiftsSection.classList.add('hidden'); return; } if (!myPastShiftsSection) { return; } myPastShiftsSection.classList.remove('hidden'); const viewType = pastShiftsViewTypeSelect.value; myPastShiftsTableBody.innerHTML = ""; let periodStart, periodEnd, displayPeriodString = ""; if (viewType === "weekly") { periodStart = getMondayOfDate(new Date(currentPastShiftViewDate)); periodEnd = new Date(periodStart); periodEnd.setDate(periodStart.getDate() + 6); periodEnd.setHours(23, 59, 59, 999); displayPeriodString = `Week of ${formatDate(periodStart, false)}`; } else { periodStart = new Date(currentPastShiftViewDate.getFullYear(), currentPastShiftViewDate.getMonth(), 1); periodEnd = new Date(currentPastShiftViewDate.getFullYear(), currentPastShiftViewDate.getMonth() + 1, 0); periodEnd.setHours(23, 59, 59, 999); displayPeriodString = `${periodStart.toLocaleString('default', { month: 'long' })} ${periodStart.getFullYear()}`; } myPastShiftsPeriodDisplay.textContent = displayPeriodString; const userPastShifts = []; try { for (const weekKey in allShiftsData) { const weekData = allShiftsData[weekKey]; if (weekData && Array.isArray(weekData.shifts)) { weekData.shifts.forEach(shift => { const shiftDate = new Date(shift.date); const isAssignedToUser = (shift.applicantName === loggedInCoworker.name) || (Array.isArray(shift.assignedCoworkers) && shift.assignedCoworkers.includes(loggedInCoworker.name)); if ( shift.status === 'approved' && isAssignedToUser && shiftDate >= periodStart && shiftDate <= periodEnd ) { userPastShifts.push(shift); } }); } } } catch (error) { myPastShiftsTableBody.innerHTML = `<tr><td colspan="3">Error loading past shifts.</td></tr>`; return; } if (userPastShifts.length === 0) { myPastShiftsTableBody.innerHTML = `<tr><td colspan="3">No approved shifts found.</td></tr>`; return; } sortShiftsArray(userPastShifts); userPastShifts.forEach(shift => { const row = myPastShiftsTableBody.insertRow(); row.insertCell().textContent = formatDate(new Date(shift.date), false); row.insertCell().textContent = shift.day; const timeCell = row.insertCell(); timeCell.textContent = shift.time; const effectiveDescription = (!shift.description && standardShiftTimes.includes(shift.time)) ? "Normal Shift" : shift.description; if(effectiveDescription){ const descSpan = document.createElement('span'); descSpan.className='shift-description-display'; descSpan.textContent = effectiveDescription; timeCell.appendChild(descSpan);} }); }
        async function renderTotalHoursSummary() { totalHoursSummaryTableBody.innerHTML = ""; const period = totalHoursPeriodSelect.value; const summaryData = {}; coworkers.forEach(c => summaryData[c.name] = 0); let shiftsToConsider = []; const processShiftHours = (shift) => { if (standardShiftTimes.includes(shift.time)) return SHIFT_DURATION_HOURS; if (shift.time && shift.time.includes(' - ')) { try { const [startStr, endStr] = shift.time.split(' - '); const [startH, startM] = startStr.split(':').map(Number); const [endH, endM] = endStr.split(':').map(Number); if (!isNaN(startH) && !isNaN(startM) && !isNaN(endH) && !isNaN(endM)) { const startDate = new Date(0,0,0,startH,startM); const endDate = new Date(0,0,0,endH,endM); let diffMillis = endDate - startDate; if (diffMillis < 0) diffMillis += 24 * 60 * 60 * 1000; return diffMillis / (1000 * 60 * 60); } } catch(e) { return 0; } } return 0; }; if (period === "viewing_week") { const weekData = await getShiftsForWeek(currentViewingDateMgr); if (weekData && Array.isArray(weekData.shifts)) shiftsToConsider = weekData.shifts; } else if (period === "viewing_month") { const targetMonth = currentViewingDateMgr.getMonth(); const targetYear = currentViewingDateMgr.getFullYear(); for (const weekKey in allShiftsData) { if (allShiftsData[weekKey] && Array.isArray(allShiftsData[weekKey].shifts)) { const weekStartDate = new Date(weekKey); if(weekStartDate.getMonth() === targetMonth && weekStartDate.getFullYear() === targetYear) { shiftsToConsider = shiftsToConsider.concat(allShiftsData[weekKey].shifts); } } } } else if (period === "all_loaded") { for (const weekKey in allShiftsData) { if (allShiftsData[weekKey] && Array.isArray(allShiftsData[weekKey].shifts)) { shiftsToConsider = shiftsToConsider.concat(allShiftsData[weekKey].shifts); } } } shiftsToConsider.filter(s => s.status === "approved").forEach(s => { const duration = processShiftHours(s); if (s.applicantName && summaryData.hasOwnProperty(s.applicantName)) { summaryData[s.applicantName] += duration; } else if (Array.isArray(s.assignedCoworkers)) { s.assignedCoworkers.forEach(name => { if(summaryData.hasOwnProperty(name)) summaryData[name] += duration; }); } }); const sortedCoworkerNames = Object.keys(summaryData).sort(); sortedCoworkerNames.forEach(name => { const row = totalHoursSummaryTableBody.insertRow(); row.insertCell().textContent = name; row.insertCell().textContent = summaryData[name].toFixed(1) + " hrs"; }); }
        async function applyForShift(shiftId, weekKey) { if (!loggedInCoworker) { await showAlert("You must be logged in."); return; } const weekDocRef = db.collection('shifts').doc(weekKey); try { await db.runTransaction(async (transaction) => { const weekDoc = await transaction.get(weekDocRef); if (!weekDoc.exists) throw "Shift data not found!"; const weekData = weekDoc.data(); if (!weekData || !Array.isArray(weekData.shifts)) throw "Invalid week data."; const shiftIndex = weekData.shifts.findIndex(s => s.id === shiftId); if (shiftIndex === -1) throw "Shift not found!"; const shift = weekData.shifts[shiftIndex]; if (shift.status === 'approved') { await showAlert("Shift already approved."); return; } if (!Array.isArray(shift.applicants)) shift.applicants = []; if (shift.applicants.includes(loggedInCoworker.name)) { await showAlert("Already applied."); return; } weekData.shifts[shiftIndex].applicants.push(loggedInCoworker.name); weekData.shifts[shiftIndex].status = "pending"; weekData.shifts[shiftIndex].applicantName = ""; transaction.update(weekDocRef, { shifts: weekData.shifts }); allShiftsData[weekKey] = JSON.parse(JSON.stringify(weekData)); }); await renderCurrentUserApplicationWeek(); } catch (error) { console.error("Error applying for shift:", error); await showAlert("Failed to apply: " + error.message); } }
        async function cancelApplication(shiftId, weekKey) { if (!loggedInCoworker) return; const weekDocRef = db.collection('shifts').doc(weekKey); try { await db.runTransaction(async (transaction) => { const weekDoc = await transaction.get(weekDocRef); if (!weekDoc.exists) throw "Shift data not found!"; const weekData = weekDoc.data(); if (!weekData || !Array.isArray(weekData.shifts)) throw "Invalid week data."; const shiftIndex = weekData.shifts.findIndex(s => s.id === shiftId); if (shiftIndex === -1) throw "Shift not found!"; const shift = weekData.shifts[shiftIndex]; if (!Array.isArray(shift.applicants)) shift.applicants = []; if (shift.status !== 'pending' || !shift.applicants.includes(loggedInCoworker.name)) { await showAlert("Cannot cancel."); return; } weekData.shifts[shiftIndex].applicants = shift.applicants.filter(name => name !== loggedInCoworker.name); if (weekData.shifts[shiftIndex].applicants.length === 0) { weekData.shifts[shiftIndex].status = "available"; } transaction.update(weekDocRef, { shifts: weekData.shifts }); allShiftsData[weekKey] = JSON.parse(JSON.stringify(weekData)); }); await renderCurrentUserApplicationWeek(); } catch (error) { console.error("Error cancelling application:", error); await showAlert("Failed to cancel: " + error.message); } }

        async function managerApproveMultipleApplicants(shiftId, weekKey, selectedApplicantNames) {
            const weekDocRef = db.collection('shifts').doc(weekKey);
            try {
                await db.runTransaction(async (transaction) => {
                    const weekDoc = await transaction.get(weekDocRef);
                    if (!weekDoc.exists) throw "Shift data not found!";
                    const weekData = weekDoc.data();
                    if (!weekData || !Array.isArray(weekData.shifts)) throw "Invalid week data.";
                    const shiftIndex = weekData.shifts.findIndex(s => s.id === shiftId);
                    if (shiftIndex === -1) throw "Shift not found!";
                    if (weekData.shifts[shiftIndex].status !== 'pending') {
                        await showAlert("Shift is no longer pending. Refresh and try again.");
                        return;
                    }
                    weekData.shifts[shiftIndex].status = "approved";
                    weekData.shifts[shiftIndex].applicantName = "";
                    weekData.shifts[shiftIndex].assignedCoworkers = selectedApplicantNames;
                    weekData.shifts[shiftIndex].applicants = [];
                    transaction.update(weekDocRef, { shifts: weekData.shifts });
                    allShiftsData[weekKey] = JSON.parse(JSON.stringify(weekData));
                });
                await refreshManagerDashboard();
                await prepareUserView();
            } catch (error) {
                console.error("Error approving multiple applicants:", error);
                await showAlert("Failed to approve applicants: " + error.message);
            }
        }

        async function managerApproveSelectedApplicant(shiftId, weekKey, selectedApplicantName) {
            await managerApproveMultipleApplicants(shiftId, weekKey, [selectedApplicantName]);
        }

        async function managerDenyAllApplicants(shiftId, weekKey) { const weekDocRef = db.collection('shifts').doc(weekKey); try { await db.runTransaction(async (transaction) => { const weekDoc = await transaction.get(weekDocRef); if (!weekDoc.exists) throw "Shift data not found!"; const weekData = weekDoc.data(); if (!weekData || !Array.isArray(weekData.shifts)) throw "Invalid week data."; const shiftIndex = weekData.shifts.findIndex(s => s.id === shiftId); if (shiftIndex === -1) throw "Shift not found!"; weekData.shifts[shiftIndex].status = "available"; weekData.shifts[shiftIndex].applicantName = ""; weekData.shifts[shiftIndex].applicants = []; weekData.shifts[shiftIndex].assignedCoworkers = []; transaction.update(weekDocRef, { shifts: weekData.shifts }); allShiftsData[weekKey] = JSON.parse(JSON.stringify(weekData)); }); await refreshManagerDashboard(); await prepareUserView(); } catch (error) { console.error("Error denying applicants:", error); await showAlert("Failed to deny: " + error.message); } }
        async function managerClearApprovedShift(shiftId, weekKey) { const weekDocRef = db.collection('shifts').doc(weekKey); try { await db.runTransaction(async (transaction) => { const weekDoc = await transaction.get(weekDocRef); if (!weekDoc.exists) throw "Shift data not found!"; const weekData = weekDoc.data(); if (!weekData || !Array.isArray(weekData.shifts)) throw "Invalid week data."; const shiftIndex = weekData.shifts.findIndex(s => s.id === shiftId); if (shiftIndex === -1) throw "Shift not found!"; if (weekData.shifts[shiftIndex].status !== 'approved') { await showAlert("Shift not approved."); return; } weekData.shifts[shiftIndex].status = "available"; weekData.shifts[shiftIndex].applicantName = ""; weekData.shifts[shiftIndex].applicants = []; weekData.shifts[shiftIndex].assignedCoworkers = []; transaction.update(weekDocRef, { shifts: weekData.shifts }); allShiftsData[weekKey] = JSON.parse(JSON.stringify(weekData)); }); await refreshManagerDashboard(); await prepareUserView(); } catch (error) { console.error("Error clearing shift:", error); await showAlert("Failed to clear: " + error.message); } }

        async function managerManuallyAssignMultipleShift(shiftId, weekKey, coworkerNames) {
            if (!Array.isArray(coworkerNames) || coworkerNames.length === 0) { await showAlert("Select at least one coworker."); return; }
            const weekDocRef = db.collection('shifts').doc(weekKey);
            try {
                await db.runTransaction(async (transaction) => {
                    const weekDoc = await transaction.get(weekDocRef);
                    if (!weekDoc.exists) throw "Shift data not found!";
                    const weekData = weekDoc.data();
                    if (!weekData || !Array.isArray(weekData.shifts)) throw "Invalid week data.";
                    const shiftIndex = weekData.shifts.findIndex(s => s.id === shiftId);
                    if (shiftIndex === -1) throw "Shift not found!";
                    weekData.shifts[shiftIndex].status = "approved";
                    weekData.shifts[shiftIndex].applicantName = ""; 
                    weekData.shifts[shiftIndex].applicants = [];
                    weekData.shifts[shiftIndex].assignedCoworkers = coworkerNames;
                    transaction.update(weekDocRef, { shifts: weekData.shifts });
                    allShiftsData[weekKey] = JSON.parse(JSON.stringify(weekData));
                });
                await refreshManagerDashboard();
                await prepareUserView();
            } catch (error) {
                console.error("Error assigning shift:", error);
                await showAlert("Failed to assign: " + error.message);
            }
        }

        async function handlePublishWeekToggle() { const weekKeyToPublish = getWeekKey(currentViewingDateMgr); const weekDocRefToPublish = db.collection('shifts').doc(weekKeyToPublish); try { const docToPublish = await weekDocRefToPublish.get(); if (!docToPublish.exists) { await showAlert("Cannot publish a non-existent week."); return; } const dataToPublish = docToPublish.data(); if (!dataToPublish || typeof dataToPublish.isPublished !== 'boolean') { await showAlert("Week data invalid."); return; } if (dataToPublish.isPublished) { const doUnpublish = await showConfirm(`Unpublish week of ${formatDate(currentViewingDateMgr, false)}?`); if (doUnpublish) { await weekDocRefToPublish.update({ isPublished: false }); if (allShiftsData[weekKeyToPublish]) { allShiftsData[weekKeyToPublish].isPublished = false; } await showAlert(`Week of ${formatDate(currentViewingDateMgr, false)} Unpublished.`); } else { return; } } else { const publishedWeeksQuery = db.collection('shifts').where('isPublished', '==', true); const snapshot = await publishedWeeksQuery.get(); let previouslyPublishedWeekKey = null; let previouslyPublishedWeekDocRef = null; snapshot.forEach(doc => { if (doc.id !== weekKeyToPublish) { previouslyPublishedWeekKey = doc.id; previouslyPublishedWeekDocRef = doc.ref; } }); let doPublishCurrentWeek = true; if (previouslyPublishedWeekKey) { const confirmUnpublishOld = await showConfirm( `Week of ${formatDate(new Date(weekKeyToPublish), false)} is about to be published.\n` + `The week of ${formatDate(new Date(previouslyPublishedWeekKey), false)} is currently published.\n\n` + `Unpublish the week of ${formatDate(new Date(previouslyPublishedWeekKey), false)} first?` ); if (confirmUnpublishOld) { await previouslyPublishedWeekDocRef.update({ isPublished: false }); if (allShiftsData[previouslyPublishedWeekKey]) { allShiftsData[previouslyPublishedWeekKey].isPublished = false; } } } else { const confirmPublish = await showConfirm(`Publish week of ${formatDate(currentViewingDateMgr, false)}?`); if (!confirmPublish) { doPublishCurrentWeek = false; } } if (doPublishCurrentWeek) { await weekDocRefToPublish.update({ isPublished: true }); if (allShiftsData[weekKeyToPublish]) { allShiftsData[weekKeyToPublish].isPublished = true; } else { const freshData = (await weekDocRefToPublish.get()).data(); if (freshData) { freshData.isPublished = true; allShiftsData[weekKeyToPublish] = JSON.parse(JSON.stringify(freshData)); } } await showAlert(`Week of ${formatDate(currentViewingDateMgr, false)} Published.`); } } await refreshManagerDashboard(); await prepareUserView(); } catch (error) { console.error("Error toggling publish status:", error); await showAlert("Failed to toggle publish status: " + error.message); } }

        function resetAddShiftForm() { editingShiftId = null; if(addUpdateShiftTitle) addUpdateShiftTitle.textContent = "Add New Shift to Current Week"; if(managerAddShiftBtn) managerAddShiftBtn.textContent = "Add Shift"; if(cancelEditShiftBtn) cancelEditShiftBtn.classList.add('hidden'); if(addShiftDaySelect) addShiftDaySelect.value = "Monday"; if(addShiftTimeTypeSelect) addShiftTimeTypeSelect.value = standardShiftTimes[0]; if(addShiftCustomStartTimeInput) addShiftCustomStartTimeInput.value = ""; if(addShiftCustomEndTimeInput) addShiftCustomEndTimeInput.value = ""; if(addShiftDescriptionInput) addShiftDescriptionInput.value = ""; if(customTimeInputsDiv) customTimeInputsDiv.classList.add('hidden'); if(descriptionInputGroup) descriptionInputGroup.classList.add('hidden'); if(assignCoworkersForCustomShiftDiv) { assignCoworkersForCustomShiftDiv.classList.add('hidden'); assignCoworkersForCustomShiftDiv.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false); } }
        
        function managerEditShiftAssignments(shiftToEdit) { // This now opens the TOP form, not the new modal.
            editingShiftId = shiftToEdit.id; 
            addUpdateShiftTitle.textContent = "Update Shift Details / Assignments"; 
            managerAddShiftBtn.textContent = "Update Shift"; 
            cancelEditShiftBtn.classList.remove('hidden'); 
            addShiftDaySelect.value = shiftToEdit.day; 
            const isCustom = isCustomTimeShift(shiftToEdit.time); 
            addShiftTimeTypeSelect.value = isCustom ? "custom" : shiftToEdit.time; 
            customTimeInputsDiv.classList.toggle('hidden', !isCustom); 
            descriptionInputGroup.classList.toggle('hidden', !isCustom && !standardShiftTimes.includes(shiftToEdit.time)); // Show description for custom, or if it exists
            
            if (isCustom) { 
                const [startTime, endTime] = shiftToEdit.time.split(' - '); 
                addShiftCustomStartTimeInput.value = startTime || ""; 
                addShiftCustomEndTimeInput.value = endTime || ""; 
                addShiftDescriptionInput.value = shiftToEdit.description || ""; 
            } else { 
                addShiftDescriptionInput.value = (shiftToEdit.description && shiftToEdit.description !== "Normal Shift") ? shiftToEdit.description : ""; 
            }
            
            assignCoworkersForCustomShiftDiv.classList.remove('hidden'); // Always show this when editing from here
            const currentAssignees = shiftToEdit.assignedCoworkers && shiftToEdit.assignedCoworkers.length > 0 ? shiftToEdit.assignedCoworkers : [];
            assignCoworkersForCustomShiftDiv.querySelectorAll('input[type="checkbox"]').forEach(cb => { 
                cb.checked = currentAssignees.includes(cb.value); 
            });
            addUpdateShiftTitle.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        function isCustomTimeShift(timeStr) { return !standardShiftTimes.includes(timeStr); }

        async function managerAddNewShift() {
            if (!currentViewingDateMgr) { await showAlert("No week selected."); return; }
            const selectedDay = addShiftDaySelect.value;
            const timeType = addShiftTimeTypeSelect.value;
            const isCustomSelected = timeType === 'custom';
            let description = (isCustomSelected && descriptionInputGroup && !descriptionInputGroup.classList.contains('hidden')) ? addShiftDescriptionInput.value.trim() : addShiftDescriptionInput.value.trim(); // Allow description for standard if field is visible
            
            let shiftTimeStr;
            let selectedAssignees = [];

            if (isCustomSelected) {
                const startTime = addShiftCustomStartTimeInput.value;
                const endTime = addShiftCustomEndTimeInput.value;
                if (!startTime || !endTime) { await showAlert("Enter start and end times for custom shift."); return; }
                if (startTime >= endTime) { await showAlert("Start time must be before end time."); return; }
                shiftTimeStr = `${startTime} - ${endTime}`;
            } else {
                shiftTimeStr = timeType;
                if (!description) { description = "Normal Shift"; }
            }
            if (!assignCoworkersForCustomShiftDiv.classList.contains('hidden')) {
                const checkboxes = assignCoworkersForCustomShiftDiv.querySelectorAll('input[type="checkbox"]:checked');
                checkboxes.forEach(cb => selectedAssignees.push(cb.value));
            }

            const weekKey = getWeekKey(currentViewingDateMgr);
            const shiftSpecificDateISO = getDateForDayInWeek(selectedDay, currentViewingDateMgr);
            if (!shiftSpecificDateISO) { await showAlert("Could not determine date."); return; }

            const weekDocRef = db.collection('shifts').doc(weekKey);
            try {
                await db.runTransaction(async (transaction) => {
                    const weekDoc = await transaction.get(weekDocRef);
                    let weekData;
                    if (!weekDoc.exists) { weekData = { shifts: [], isPublished: false }; }
                    else { weekData = weekDoc.data(); if (!Array.isArray(weekData.shifts)) weekData.shifts = []; }

                    if (editingShiftId) { // This logic is for when the TOP form is used for an existing shift
                        const shiftIndex = weekData.shifts.findIndex(s => s.id === editingShiftId);
                        if (shiftIndex === -1) throw new Error("Shift to edit not found.");
                        const effectiveDescription = (isCustomSelected || description) ? description : "Normal Shift";
                        // Check for conflicts only if fundamental details (day, time, description) change from how the edit was initiated
                        // This conflict check might need refinement if editing just assignees from top form
                        weekData.shifts[shiftIndex].day = selectedDay;
                        weekData.shifts[shiftIndex].date = shiftSpecificDateISO;
                        weekData.shifts[shiftIndex].time = shiftTimeStr;
                        weekData.shifts[shiftIndex].description = effectiveDescription;
                        weekData.shifts[shiftIndex].assignedCoworkers = selectedAssignees;
                        weekData.shifts[shiftIndex].applicantName = ""; 
                        weekData.shifts[shiftIndex].status = selectedAssignees.length > 0 ? "approved" : "available";
                        weekData.shifts[shiftIndex].applicants = [];
                    } else { // Adding a completely new shift via the top form
                        const effectiveDescription = (isCustomSelected || description) ? description : "Normal Shift";
                        const existingShift = weekData.shifts.find(s => s.day === selectedDay && s.time === shiftTimeStr && (s.description || "Normal Shift") === effectiveDescription);
                        if (existingShift) { throw new Error(`A shift for ${selectedDay} at ${shiftTimeStr} ${effectiveDescription ? 'with description "'+effectiveDescription+'"' : ''} already exists.`); }
                        const newShift = { id: `${weekKey}-${Date.now()}`, day: selectedDay, date: shiftSpecificDateISO, time: shiftTimeStr, status: selectedAssignees.length > 0 ? "approved" : "available", applicants: [], applicantName: "", description: effectiveDescription, assignedCoworkers: selectedAssignees };
                        weekData.shifts.push(newShift);
                    }
                    sortShiftsArray(weekData.shifts);
                    if (!weekDoc.exists) { transaction.set(weekDocRef, weekData); }
                    else { transaction.update(weekDocRef, { shifts: weekData.shifts }); }
                    allShiftsData[weekKey] = JSON.parse(JSON.stringify(weekData));
                });
                await showAlert(editingShiftId ? "Shift updated." : `Shift added: ${selectedDay}, ${shiftTimeStr}.`);
                resetAddShiftForm();
                await refreshManagerDashboard();
            } catch (error) { console.error("Error adding/updating shift:", error); await showAlert("Failed to save shift: " + error.message); }
        }
        async function managerDeleteShift(shiftId, weekKey) {
            const doDelete = await showConfirm("Are you sure you want to permanently delete this shift?");
            if (!doDelete) return;
            const weekDocRef = db.collection('shifts').doc(weekKey);
            try {
                await db.runTransaction(async (transaction) => {
                    const weekDoc = await transaction.get(weekDocRef);
                    if (!weekDoc.exists) throw "Shift data for this week not found!";
                    const weekData = weekDoc.data();
                    if (!weekData || !Array.isArray(weekData.shifts)) throw "Invalid week data structure.";
                    weekData.shifts = weekData.shifts.filter(s => s.id !== shiftId);
                    transaction.update(weekDocRef, { shifts: weekData.shifts });
                    if (allShiftsData[weekKey]) {
                        allShiftsData[weekKey].shifts = weekData.shifts.map(s => JSON.parse(JSON.stringify(s)));
                    }
                });
                await showAlert("Shift deleted successfully.");
                await refreshManagerDashboard();
                await prepareUserView();
            } catch (error) {
                console.error("Error deleting shift:", error);
                await showAlert("Failed to delete shift: " + error.message);
            }
        }
        function populateCoworkerCheckboxesForCustomShift() { assignCoworkersForCustomShiftDiv.innerHTML = '<h4>Assign Coworkers:</h4>'; coworkers.sort((a,b) => a.name.localeCompare(b.name)).forEach(cw => { const checkboxId = `assign-cw-${cw.id || cw.name.replace(/\s+/g, '-')}`; const label = document.createElement('label'); label.htmlFor = checkboxId; label.style.marginRight = "10px"; const checkbox = document.createElement('input'); checkbox.type = "checkbox"; checkbox.id = checkboxId; checkbox.value = cw.name; label.appendChild(checkbox); label.appendChild(document.createTextNode(` ${cw.name}`)); assignCoworkersForCustomShiftDiv.appendChild(label); }); }
        function renderCoworkerListForManager() { coworkerListDiv.innerHTML = "<h4>Current Coworkers:</h4>"; if (coworkers.length === 0) { coworkerListDiv.innerHTML += "<p>No coworkers.</p>"; return; } const ul = document.createElement('ul'); ul.style.listStyleType = 'none'; ul.style.paddingLeft = '0'; coworkers.sort((a, b) => a.name.localeCompare(b.name)).forEach(c => { const li = document.createElement('li'); li.classList.add('coworker-management-item'); const nameSpan = document.createElement('span'); nameSpan.textContent = `${c.name} ${c.isManager ? '(Mgr)' : ''}`; li.appendChild(nameSpan); const actionDiv = document.createElement('div'); const changePassBtn = document.createElement('button'); changePassBtn.textContent = "Pwd"; changePassBtn.classList.add("secondary", "small-action"); changePassBtn.onclick = () => handleChangeCoworkerPassword(c.id || c.name); actionDiv.appendChild(changePassBtn); const toggleMgrBtn = document.createElement('button'); toggleMgrBtn.textContent = c.isManager ? "Demote" : "Promote"; toggleMgrBtn.classList.add("secondary", "small-action"); toggleMgrBtn.onclick = () => handleToggleManagerStatus(c.id || c.name); actionDiv.appendChild(toggleMgrBtn); const deleteBtn = document.createElement('button'); deleteBtn.textContent = "Del"; deleteBtn.classList.add("delete", "small-action"); deleteBtn.onclick = () => handleDeleteCoworker(c.id || c.name); actionDiv.appendChild(deleteBtn); li.appendChild(actionDiv); ul.appendChild(li); }); coworkerListDiv.appendChild(ul); }
        async function handleAddCoworker() {
            const name = newCoworkerNameInput.value.trim();
            const password = newCoworkerPasswordInput.value;
            const isManager = newCoworkerIsManagerCheckbox.checked;
            if (!name || !password) { await showAlert("Name and password required."); return; }
            if (coworkers.find(c => c.name.toLowerCase() === name.toLowerCase())) { await showAlert("Coworker name already exists."); return; }
            try {
                await db.collection('coworkers').doc(name).set({ name, password, isManager });
                await initializeCoworkers();
                populateLoginUserDropdown();
                renderCoworkerListForManager();
                populateCoworkerCheckboxesForCustomShift();
                newCoworkerNameInput.value = "";
                newCoworkerPasswordInput.value = "";
                newCoworkerIsManagerCheckbox.checked = false;
                await showAlert(`${name} added.`);
            } catch (error) {
                console.error("Error adding coworker:", error);
                await showAlert("Failed to add: " + error.message);
            }
        }
        async function handleDeleteCoworker(coworkerDocIdOrName) {
            const coworkerToDelete = coworkers.find(c => c.id === coworkerDocIdOrName || c.name === coworkerDocIdOrName);
            if (!coworkerToDelete) { await showAlert("Coworker not found."); return;}
            if (coworkerToDelete.isManager && coworkers.filter(c => c.isManager).length <= 1) { await showAlert("Cannot delete the last manager."); return; }
            const doDelete = await showConfirm(`Delete ${coworkerToDelete.name}? This will also remove their assignments and applications.`);
            if (!doDelete) return;
            try {
                await db.collection('coworkers').doc(coworkerToDelete.id || coworkerToDelete.name).delete();
                const shiftsCollectionRef = db.collection('shifts');
                const querySnapshot = await shiftsCollectionRef.get();
                const batch = db.batch();
                let changesMadeToShifts = false;
                querySnapshot.forEach(weekDoc => {
                    const weekKey = weekDoc.id;
                    const weekData = weekDoc.data();
                    if (!weekData || !Array.isArray(weekData.shifts)) return;
                    let weekModified = false;
                    const updatedShifts = weekData.shifts.map(shift => {
                        let shiftChanged = false;
                        if (shift.applicantName === coworkerToDelete.name) { shift.applicantName = ""; shift.status = "available"; shift.assignedCoworkers = []; shiftChanged = true; }
                        if (Array.isArray(shift.applicants) && shift.applicants.includes(coworkerToDelete.name)) { shift.applicants = shift.applicants.filter(name => name !== coworkerToDelete.name); if (shift.status === "pending" && shift.applicants.length === 0) { shift.status = "available"; } shiftChanged = true; }
                        if (Array.isArray(shift.assignedCoworkers) && shift.assignedCoworkers.includes(coworkerToDelete.name)){ shift.assignedCoworkers = shift.assignedCoworkers.filter(name => name !== coworkerToDelete.name); if(shift.status === "approved" && shift.assignedCoworkers.length === 0 && !shift.applicantName) {shift.status = "available";} shiftChanged = true;}
                        if(shiftChanged) weekModified = true; return shift;
                    });
                    if (weekModified) { batch.update(shiftsCollectionRef.doc(weekKey), { shifts: updatedShifts }); changesMadeToShifts = true; if (allShiftsData[weekKey]) { allShiftsData[weekKey].shifts = updatedShifts.map(s => JSON.parse(JSON.stringify(s)));} }
                });
                if (changesMadeToShifts) { await batch.commit(); }
                await initializeCoworkers();
                populateLoginUserDropdown();
                populateCoworkerCheckboxesForCustomShift();
                if (loggedInCoworker && loggedInCoworker.name === coworkerToDelete.name) logout();
                else { if (isManagerModeActive) await refreshManagerDashboard(); await prepareUserView(); }
                await showAlert(`${coworkerToDelete.name} deleted.`);
            } catch (error) {
                console.error("Error deleting coworker:", error);
                await showAlert("Failed to delete: " + error.message);
            }
        }
        async function handleChangeCoworkerPassword(coworkerDocIdOrName) {
            const newPassword = await showPrompt(`Enter new password for this coworker:`);
            if (newPassword === null) return;
            if (!newPassword.trim()) { await showAlert("Password cannot be empty."); return; }
            try {
                await db.collection('coworkers').doc(coworkerDocIdOrName).update({ password: newPassword.trim() });
                const localCoworker = coworkers.find(c => c.id === coworkerDocIdOrName || c.name === coworkerDocIdOrName);
                if (localCoworker) localCoworker.password = newPassword.trim();
                if (loggedInCoworker && (loggedInCoworker.id === coworkerDocIdOrName || loggedInCoworker.name === coworkerDocIdOrName)) {
                    loggedInCoworker.password = newPassword.trim();
                    localStorage.setItem(ACTIVE_SESSION_USER_KEY, JSON.stringify({name: loggedInCoworker.name, password: loggedInCoworker.password}));
                }
                await showAlert(`Password updated.`);
            } catch (error) {
                console.error("Error changing password:", error);
                await showAlert("Failed to change: " + error.message);
            }
        }
        async function handleToggleManagerStatus(coworkerDocIdOrName) {
            const coworkerToToggle = coworkers.find(c => c.id === coworkerDocIdOrName || c.name === coworkerDocIdOrName);
            if (!coworkerToToggle) return;
            const newManagerStatus = !coworkerToToggle.isManager;
            if (coworkerToToggle.isManager && coworkers.filter(c => c.isManager).length <= 1) { await showAlert("Cannot demote the last manager."); return; }
            try {
                await db.collection('coworkers').doc(coworkerDocIdOrName).update({ isManager: newManagerStatus });
                coworkerToToggle.isManager = newManagerStatus;
                renderCoworkerListForManager();
                if (loggedInCoworker && (loggedInCoworker.id === coworkerDocIdOrName || loggedInCoworker.name === coworkerDocIdOrName)) {
                    loggedInCoworker.isManager = newManagerStatus;
                    accessManagerPanelBtn.classList.toggle('hidden', !loggedInCoworker.isManager);
                    if (!loggedInCoworker.isManager && isManagerModeActive) { isManagerModeActive = false; showCorrectView(); }
                }
                await showAlert(`Manager status updated for ${coworkerToToggle.name}.`);
            } catch (error) {
                console.error("Error toggling manager status:", error);
                await showAlert("Failed to toggle: " + error.message);
            }
        }
        async function handleSubmitChangeMasterPassword() { changeMasterPassError.textContent = ""; changeMasterPassSuccess.textContent = ""; const currentPassAttempt = currentMasterPasswordInput.value; const newPass = newMasterPasswordInput.value; const confirmPass = confirmNewMasterPasswordInput.value; if (currentPassAttempt !== currentMasterPassword) { changeMasterPassError.textContent = "Current Master Password incorrect."; return; } if (!newPass || newPass.length < 6) { changeMasterPassError.textContent = "New password must be at least 6 characters."; return; } if (newPass !== confirmPass) { changeMasterPassError.textContent = "New passwords do not match."; return; } try { await db.collection('config').doc('adminConfig').set({ masterAdminPassword: newPass }, { merge: true }); currentMasterPassword = newPass; changeMasterPassSuccess.textContent = "Master Admin Password changed successfully!"; currentMasterPasswordInput.value = ""; newMasterPasswordInput.value = ""; confirmNewMasterPasswordInput.value = ""; setTimeout(() => { changeMasterPasswordSection.classList.add('hidden'); changeMasterPassSuccess.textContent = ""; }, 2000); } catch (error) { console.error("Error updating master password:", error); changeMasterPassError.textContent = "Failed to update."; } }
        async function handleResetAllData() {
            const doReset = await showConfirm("This will clear your local session. Data in Firestore will NOT be deleted by this action. This action is primarily for development & testing. Are you sure?");
            if (doReset) {
                loggedInCoworker = null;
                isManagerModeActive = false;
                localStorage.removeItem(ACTIVE_SESSION_USER_KEY);
                allShiftsData = {};
                await initializeApp();
                await showAlert("Local session reset. App re-initialized data (may fetch from Firestore or use defaults if Firestore is empty).");
            }
        }

        // --- Assign/Edit Modal Logic ---
        function openAssignEditModal(shift, weekKey, isEditing) {
            currentShiftForModal = { ...shift, weekKey: weekKey }; // Store shift context
            assignEditModalTitle.textContent = isEditing ? `Edit Assignments for ${shift.day} ${shift.time}` : `Assign Coworkers for ${shift.day} ${shift.time}`;
            
            assignEditCoworkerListDiv.innerHTML = ''; // Clear previous list
            coworkers.sort((a,b) => a.name.localeCompare(b.name)).forEach(cw => {
                const checkboxId = `modal-assign-cw-${cw.id || cw.name.replace(/\s+/g, '-')}`;
                const label = document.createElement('label');
                const checkbox = document.createElement('input');
                checkbox.type = "checkbox";
                checkbox.id = checkboxId;
                checkbox.value = cw.name;
                checkbox.name = "modalCoworkerAssign";
                
                if (isEditing && shift.assignedCoworkers && shift.assignedCoworkers.includes(cw.name)) {
                    checkbox.checked = true;
                }
                
                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(` ${cw.name}`));
                assignEditCoworkerListDiv.appendChild(label);
            });
            
            assignEditModal.classList.remove('hidden');
            assignEditModal.style.display = 'flex';
        }

        assignEditCancelBtn.addEventListener('click', () => {
            assignEditModal.classList.add('hidden');
            assignEditModal.style.display = 'none';
            currentShiftForModal = null;
        });

        assignEditSaveBtn.addEventListener('click', async () => {
            if (!currentShiftForModal) return;

            const selectedCoworkers = [];
            assignEditCoworkerListDiv.querySelectorAll('input[name="modalCoworkerAssign"]:checked').forEach(checkbox => {
                selectedCoworkers.push(checkbox.value);
            });

            const weekKey = currentShiftForModal.weekKey;
            const shiftId = currentShiftForModal.id;
            const weekDocRef = db.collection('shifts').doc(weekKey);

            try {
                await db.runTransaction(async (transaction) => {
                    const weekDoc = await transaction.get(weekDocRef);
                    if (!weekDoc.exists) throw "Shift data not found!";
                    const weekData = weekDoc.data();
                    if (!weekData || !Array.isArray(weekData.shifts)) throw "Invalid week data.";
                    
                    const shiftIndex = weekData.shifts.findIndex(s => s.id === shiftId);
                    if (shiftIndex === -1) throw "Shift not found in week data!";

                    weekData.shifts[shiftIndex].assignedCoworkers = selectedCoworkers;
                    weekData.shifts[shiftIndex].applicantName = ""; // Clear single applicant name if any
                    weekData.shifts[shiftIndex].applicants = []; // Clear pending applicants as it's now directly assigned/edited

                    if (selectedCoworkers.length > 0) {
                        weekData.shifts[shiftIndex].status = "approved";
                    } else {
                        // If no one is assigned after edit, make it available
                        weekData.shifts[shiftIndex].status = "available";
                    }
                    
                    transaction.update(weekDocRef, { shifts: weekData.shifts });
                    allShiftsData[weekKey] = JSON.parse(JSON.stringify(weekData));
                });
                assignEditModal.classList.add('hidden');
                assignEditModal.style.display = 'none';
                await refreshManagerDashboard();
                await prepareUserView();
                currentShiftForModal = null;
            } catch (error) {
                console.error("Error saving assignments from modal:", error);
                await showAlert("Failed to save assignments: " + error.message);
            }
        });


        // --- END Assign/Edit Modal Logic ---


        coworkerLoginBtn.addEventListener('click', handleCoworkerLogin);
        loginPasswordInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleCoworkerLogin(); });
        accessManagerPanelBtn.addEventListener('click', handleAccessManagerPanel);
        userLogoutBtn.addEventListener('click', logout);
        unlockManagerPanelBtn.addEventListener('click', handleUnlockManagerPanel);
        masterManagerPasswordInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleUnlockManagerPanel(); });
        cancelManagerUnlockBtn.addEventListener('click', () => managerUnlockModal.classList.add('hidden'));
        switchToUserViewBtn.addEventListener('click', () => { isManagerModeActive = false; changeMasterPasswordSection.classList.add('hidden'); showCorrectView(); });
        managerDashboardLogoutBtn.addEventListener('click', logout);
        prevWeekBtnMgr.addEventListener('click', () => { currentViewingDateMgr.setDate(currentViewingDateMgr.getDate() - 7); refreshManagerDashboard(); });
        jumpToTargetWeekBtnMgr.addEventListener('click', () => { currentViewingDateMgr = getNextWeekStartDate(); refreshManagerDashboard(); });
        nextWeekBtnMgr.addEventListener('click', () => { currentViewingDateMgr.setDate(currentViewingDateMgr.getDate() + 7); refreshManagerDashboard(); });
        publishWeekBtn.addEventListener('click', handlePublishWeekToggle);
        showChangeMasterPassBtn.addEventListener('click', () => { changeMasterPasswordSection.classList.toggle('hidden'); changeMasterPassError.textContent = ""; changeMasterPassSuccess.textContent = ""; currentMasterPasswordInput.value = ""; newMasterPasswordInput.value = ""; confirmNewMasterPasswordInput.value = ""; });
        submitChangeMasterPassBtn.addEventListener('click', handleSubmitChangeMasterPassword);
        cancelChangeMasterPassBtn.addEventListener('click', () => { changeMasterPasswordSection.classList.add('hidden'); changeMasterPassError.textContent = ""; changeMasterPassSuccess.textContent = ""; });
        hoursViewTypeSelect.addEventListener('change', () => refreshManagerDashboard());
        totalHoursPeriodSelect.addEventListener('change', () => refreshManagerDashboard());
        resetAllDataBtn.addEventListener('click', handleResetAllData);
        addCoworkerBtn.addEventListener('click', handleAddCoworker);
        newCoworkerPasswordInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleAddCoworker(); });

        if (managerAddShiftBtn) { managerAddShiftBtn.addEventListener('click', managerAddNewShift); }
        if (cancelEditShiftBtn) { cancelEditShiftBtn.addEventListener('click', resetAddShiftForm); }
        if (addShiftTimeTypeSelect) {
            addShiftTimeTypeSelect.addEventListener('change', () => {
                const isCustom = addShiftTimeTypeSelect.value === 'custom';
                customTimeInputsDiv.classList.toggle('hidden', !isCustom);
                descriptionInputGroup.classList.toggle('hidden', !isCustom); // Show for custom
                // For add/update top form, keep assignCoworkersForCustomShiftDiv hidden unless editing/adding custom
                assignCoworkersForCustomShiftDiv.classList.toggle('hidden', !isCustom && !editingShiftId);
                 if (!isCustom && editingShiftId) { // If editing and switching to standard
                    // If the top form is used for editing, this logic applies.
                    // But with the new modal, this specific path might be less common for just assignee changes.
                    addShiftCustomStartTimeInput.value = "";
                    addShiftCustomEndTimeInput.value = "";
                    // If editing a standard shift via top form, ensure assignees are shown
                    assignCoworkersForCustomShiftDiv.classList.remove('hidden');
                } else if (!isCustom && !editingShiftId) { // Adding new standard shift via top form
                     assignCoworkersForCustomShiftDiv.classList.add('hidden');
                } else if (isCustom) { // Adding or editing custom shift via top form
                    assignCoworkersForCustomShiftDiv.classList.remove('hidden');
                }
            });
        }

        if (prevUserAppWeekBtn) { prevUserAppWeekBtn.addEventListener('click', async () => { const firstAllowedAppDate = getNextWeekStartDate(); if (currentUserApplicationViewingDate && currentUserApplicationViewingDate.getTime() > firstAllowedAppDate.getTime()) { currentUserApplicationViewingDate.setDate(currentUserApplicationViewingDate.getDate() - 7); await renderCurrentUserApplicationWeek(); } }); }
        if (nextUserAppWeekBtn) { nextUserAppWeekBtn.addEventListener('click', async () => { const firstAllowedAppDate = getNextWeekStartDate(); const lastAllowedAppDateBoundary = new Date(firstAllowedAppDate); lastAllowedAppDateBoundary.setDate(firstAllowedAppDate.getDate() + (USER_APPLICATION_WEEKS_FORWARD * 7)); if (currentUserApplicationViewingDate && getMondayOfDate(new Date(currentUserApplicationViewingDate)).getTime() < getMondayOfDate(new Date(lastAllowedAppDateBoundary)).getTime()) { currentUserApplicationViewingDate.setDate(currentUserApplicationViewingDate.getDate() + 7); await renderCurrentUserApplicationWeek(); } }); }
        prevPastPeriodBtn.addEventListener('click', () => { const viewType = pastShiftsViewTypeSelect.value; if (viewType === "weekly") { currentPastShiftViewDate.setDate(currentPastShiftViewDate.getDate() - 7); } else { currentPastShiftViewDate.setMonth(currentPastShiftViewDate.getMonth() - 1); } renderMyPastShifts(); });
        nextPastPeriodBtn.addEventListener('click', () => { const viewType = pastShiftsViewTypeSelect.value; if (viewType === "weekly") { currentPastShiftViewDate.setDate(currentPastShiftViewDate.getDate() + 7); } else { currentPastShiftViewDate.setMonth(currentPastShiftViewDate.getMonth() + 1); } renderMyPastShifts(); });
        pastShiftsViewTypeSelect.addEventListener('change', () => { currentPastShiftViewDate = getMondayOfDate(new Date()); renderMyPastShifts(); });

        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>
